<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>CIP4 xJDFLib</title>

    <abstract>
      <para>This document describes the structure and functionality of CIP4
      xJdfLib and how to use it. The library was written in Java and simplify
      dealing with JDF / JMF messages. It provides methods for creation,
      modification and analyzing.</para>
    </abstract>
  </info>

  <chapter>
    <title>Introduction</title>

    <para>The major conceptual change is that JDF 2.0 (or XJDF) no longer
    attempts to model the entire job as one large “job ticket” but rather
    specifies an interchange format between two applications that are assumed
    to have an internal data model that is not necessarily based on JDF. Thus
    each JDF ticket specifies a single transaction between two parties. A
    single job may be modeled as one or more JDF transactions.</para>

    <para>The major change in JDF Technology also is a good ability for
    rethinking about a conceptual change of the JDF library as well. The focus
    of the current library “JDFLibJ” is dealing with large XML files (XML
    files were used as data storage), managing concurrency file access (spawn
    and merge), handling the workflow logic (references) which also is part of
    the 1.x JDF Documents etc. Even there are implemented some very common XML
    functionalities like creating Java objects from XSD Schema and so
    on.</para>

    <para>Remember, the fundamental concepts of JDF (and the library) were
    designed in the nineties. At that time XML was a very new technology and
    just a few early XML Tools had existed. Further the XML technology itself
    was in a very early phase of development. So it was essential to include
    all this stuff like mentioned before to get JDF working.</para>

    <para>Over the last two decades XML has become very popular. Many tools
    were designed and many conceptual enhancements in XML have been done to
    simplify working with. For example one significant enhancement has been
    XPath. More details about the XPath W3C Standard later in this document or
    on the W3C website: http://www.w3.org/TR/xpath/.</para>

    <para>Due to the major change from JDF 1.x to JDF 2.0 it is strongly
    recommended to redesign the JDF library as well. Similarly to the new JDF
    Specification the new library “xJdfLib” also is based on commonly used
    libraries and technologies like the Apache or JAXB framework.
    Supplementary functionality which has been removed from Specification no
    longer makes the library unnecessarily complex for reasons of backwards
    compatibility. The goal of the new XJDF Library is to provide a
    lightweight, up to date and easy to use library optimized for actual
    requirements.</para>
  </chapter>

  <chapter>
    <title>The xJdfLib Java Library</title>

    <para>The CIP4 xJdfLib Java Library is based on Java 7. The latest stable
    version is being published on the CIP4 Website on page “Technical
    Resources -&gt; Downloads -&gt; Internal Source”. Further xJdfLib is an
    Apache Maven project. So the latest stable version also is available in
    the public Central Maven Repositroy:</para>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.2&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

    <para>Early Next-Version-Snapshots of CIP4 xJdfLib Library are being
    published in the public OSS Sonatype Snapshot Repository:</para>

    <programlisting language="xml">&lt;repository&gt;
    &lt;id&gt;SnapshotOSS&lt;/id&gt;
    &lt;name&gt;OSS Snapshot&lt;/name&gt;
    &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;</programlisting>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.3-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
  </chapter>

  <chapter>
    <title>Core Components</title>

    <section>
      <title>XJdfNodeFactory</title>

      <para>The XJdfNodeFactory is the fundamental factory class for creating
      new instances of XJDF Nodes. The class provides at least one
      Creation-Method per XJDF Node. For plain commonly used XJDF Nodes (e. g.
      GeneralID, RunList etc.) there also are extended Creation-Methods which
      additionally do initialize the node object after creation.</para>

      <para>A new instance of XJdfNodeFactory can created by calling the
      static method <emphasis>newInstance()</emphasis>:</para>

      <programlisting language="java">// New Factory Instance
XJdfNodeFactory xJdfNodeFactory = XJdfNodeFactory.newInstance();</programlisting>

      <para>The next two code snippets demonstrate the differance and usage of
      normal and extended Creation-Methods. For example when working with
      GeneralIDs most of them only consist of the attributes "IDUsage" and
      "IDValue". Using the flexible way the creation of GeneralID instances
      takes three lines of code. The first line creates the new object whereas
      the following two lines initialize the object by attribute values. Each
      attribute explicitly can be set and modified:</para>

      <para><programlisting language="java">// New GeneralID XJDF Node Object using the flexible way
GeneralID generalId = xJdfNodeFactory.createGeneralID();
generalId.setIDUsage("IDCatalog");
generalId.setIDValue("42");</programlisting>But when creating larger XJDF
      Documents the flexible way unnecessarily does consume time for writing
      and raise complexity enormously. Hence the factory class besides
      provides extended Creation-Methods for a straighter way. Using this
      methods plain commonly used XJDF Node structures can be created and
      initialized by a single line of code:</para>

      <para><programlisting language="java">// New GeneralID XJDF Node Object using the straight way
GeneralID generalId = xJdfNodeFactory.createGeneralID("IDCatalog","42");</programlisting></para>

      <para>Both ways produce one and the same GeneralID Node. The flexible
      way raises flexibility of attribute management whereas the straight one
      decreases complexity, maintenance and produces more clearly source
      code.</para>

      <para>Best practice is the combination of both ways. It is strongly
      recommended using the extended Creation-Methods whenever one is
      available. If the extended method does not fully fit the needs the
      result always can be individualized in a further step after. All
      attributes always are able being modified directly.</para>

      <para>Following example showcases how to modify an XJDF Node after
      creation. In some situations the<emphasis> /RunList/FileSpec</emphasis>
      Node may contain an addtional attribute
      <emphasis>UserFileName</emphasis>:</para>

      <para><programlisting language="xml">[...]
&lt;RunList&gt;
    &lt;FileSpec URL="http://192.168.1.113:80/4daction/Poster/10496" 
        UserFileName="myFileName.pdf"/&gt;
&lt;/RunList&gt;
[...]</programlisting>In the latest version of XJdfNodeFactory for example
      there is no extended Creation-Method for the creation of a
      <emphasis>RunList</emphasis> node which also defines a
      <emphasis>UserFileName</emphasis> attribute in
      <emphasis>FileSpec</emphasis>. The best practice is using the extended
      method despite and finally indivualize the result:</para>

      <para><programlisting language="java">// Best practice creating indivudal nodes
RunList runList = xJdfNodeFactory
    .createRunList("http://192.168.1.113:80/4daction/Poster/10496");
runList.getFileSpec().setUserFileName("myFileName.pdf");</programlisting></para>
    </section>

    <section>
      <title>Builder Classes</title>

      <para>Plain XJDF Node elements easily can be created using the
      XJdfNodeFactory. Complex elements (e. g. XJDF-Root-Node, Product-Node,
      etc.) are elements which contains multiple subnodes in a defined manner.
      For example you can say the XJDF-Root-Node is the container for Product
      and Paramter nodes. All <emphasis>Product</emphasis> items are listed in
      subelement <emphasis>ProductList</emphasis>. Also all
      <emphasis>Parameter</emphasis> nodes are listed in specific
      <emphasis>ParamterSet</emphasis> elements.</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0" Category="Web2Print" 
    DescriptiveName="My lovely Poster" JobID="FA-SIG-123456”&gt;
    &lt;ProductList&gt;
        &lt;Product DescriptiveName="1234_56" Amount="1500" ProductType="Poster"
            ProductID="FA-SIG-123456" ProductTypeDetails="PTD Value" &gt;
            &lt;Intent Name="MediaIntent"&gt;
                &lt;MediaIntent MediaQuality="IPM_90"/&gt;
            &lt;/Intent&gt;
        &lt;/Product&gt;
    &lt;/ProductList&gt;
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="test_file.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    &lt;ParameterSet Name="Contact"&gt;
        &lt;Parameter&gt;
            &lt;Contact ContactTypes="Customer Delivery"&gt;
                &lt;Address PostalCode="97080" City="Würzburg" 
                    Country="Germany" Street="Alfred-Nobel-Straße 18"/&gt;
                &lt;ComChannel ChannelType="Email" Locator="info@flyeralarm.de"/&gt;
                &lt;ComChannel ChannelType="Phone" Locator="+49.931.465840"/&gt;
                &lt;Company OrganizationName="flyeralarm GmbH"/&gt;
            &lt;/Contact&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
&lt;/XJDF&gt;</programlisting>Builder classes are designed and optimized for
      simplify creating the container element and dealing with all subnodes in
      a correct manner. In case of <date>XJdfBuilder</date> when adding a new
      <emphasis>Parameter</emphasis> node the class automatically checks
      whether the right <emphasis>ParameterSet</emphasis> element already does
      exist. If not so the library creates a new one and finally embeds the
      new parameter.</para>

      <para>The CIP4 XJdfLib provides several element builders:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><emphasis role="bold">XJdfBuilder</emphasis></para>

          <para>Creation of XJDF Documents. Manages dealing with Products and
          Paramters.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ProductBuilder</emphasis></para>

          <para>Creation of Product nodes. Handles Intent nodes.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ContactBuilder</emphasis></para>

          <para>Creation of Contact nodes. Simplify handling with contact
          details.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>XJdfBuilder</title>

        <para>The builder class XJdfBuilder covers logic to simplify the
        creation of XJDF Root Nodes and the handling of their Product and
        Parameter definitions. In order to add subelements there are several
        "add"-methods to achieve this. Secondary these methods are responsible
        keeping the structure of the XJDF Document in a well defined manner.
        For instance the XJDF Specification defines all Parameter nodes have
        to be embedded within a specific ParameterSet element. This mecanism
        fully is supported by the builder class. So when adding a new
        Parameter item the addParameter() method checks whether or not the
        right ParameterSet node already does exist. In case the ParameterSet
        node does not exist yet a new one is created automatically. Following
        a Java Code Snippet how to use the XJdfBuilder for creating the XJDF
        document above:</para>

        <para><programlisting language="java">// new xJdfBuilder
XJdfBuilder xJdfBuilder = XJdfBuilder.newInstance("FA-SIG-123456", 
                                             "Web2Print", "My lovely Poster");

// create Product node
ProductBuilder productBuilder = ProductBuilder.newInstance();
[...]
Product product = productBuilder.build();

// create Contact node
ContactBuilder contactBuilder = ContactBuilder.newInstance();
[...]
Contact contact = contactBuilder.build();

// create RunList
RunList runList = XJdfNodeFactory.newInstance().createRunList("test_file.pdf");

// append product
xJdfBuilder.addProduct(product);

// append parameters
xJdfBuilder.addParameter(contact);
xJdfBuilder.addParameter(runList);

// build XJDF Doc
XJDF xJdf = xJdfBuilder.build();</programlisting></para>

        <section>
          <title>Partitioning of Parameter nodes</title>

          <para>The XJDF Specification defines a partitioning mechanism of
          Parameters. Here an example of a partitioned RunList in a XJDF
          Document:</para>

          <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Cover"/&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="./artwork/cover.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Body"/&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="./artwork/body.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    [...]
&lt;/XJDF&gt;</programlisting>In XJdfBuilder class there is a particular
          addParameter() method override for partitioning. Following the
          appendant code snippet for the creation of a partitioned RunList
          ParameterSet:</para>

          <para><programlisting language="java">// new factory
XJdfNodeFactory xJdfNodeFactory = XJdfNodeFactory.newInstance();

// new XJdfBuilder
XJdfBuilder xJdfBuilder = XJdfBuilder.newInstance();

// parameter cover
RunList runListCover = xJdfNodeFactory.createRunList("./artwork/cover.pdf");

Part partCover = XJdfNodeFactory.newInstance().createPart();
partCover.setRun("Cover");

// parameter body
RunList runListBody = xJdfNodeFactory.createRunList("./artwork/body.pdf");

Part partBody = XJdfNodeFactory.newInstance().createPart();
partBody.setRun("Body");

// add parameters with partitioning
xJdfBuilder.addParameter(runListCover, partCover);
xJdfBuilder.addParameter(runListBody, partBody);

// build XJDF
XJDF xJdf = xJdfBuilder.build();</programlisting></para>
        </section>
      </section>

      <section>
        <title>ProductBuilder</title>

        <para>The main task of ProductBuilder is the creation and
        initialization of new product instances. Further the classes proper is
        the handling of product Intents. In XJDF each product intent has to be
        embedded within a separate Intent node. This mechanism also is covered
        by the ProductBuilder. When adding a new concrete Intent node (e. g.
        MediaIntent, LayoutIntent etc.) the class manages the
        structure.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ProductList&gt;
        &lt;Product ProductTypeDetails="MyJob" Amount="1500" ProductType="Poster"
            ProductID="FA-SIG-123456" &gt;
            &lt;Intent Name="MediaIntent"&gt;
                &lt;MediaIntent Weight="135.0" /&gt;
            &lt;/Intent&gt;
            &lt;Intent Name="LayoutIntent"&gt;
                &lt;LayoutIntent FinishedDimensions="595.27559055 822.04724409" /&gt;
            &lt;/Intent&gt;
            &lt;Intent Name="BindingIntent"&gt;
                &lt;BindingIntent BindingType="SaddleStitch" /&gt;
            &lt;/Intent&gt;
        &lt;/Product&gt;
    &lt;/ProductList&gt;
    [...]
&lt;/XJDF&gt;</programlisting>The snippet above shows a Product definition
        within a XJDF Document. Using the ProductBuilder class there is no
        longer a need managing the document structure manually. The only thing
        to do is creating the particular Intent elements and add them to the
        builder:</para>

        <para><programlisting language="java">// new ProductBuilder instance 
ProductBuilder productBuilder = ProductBuilder.newInstance(1500, 
                                  "FA-SIG-123456", "Poster", "MyJob");

// create Intents
MediaIntent mediaIntent = [...];
LayoutIntent layoutIntent = [...];
BindingIntent bindingIntent = [...];

// add Intents
productBuilder.addIntent(mediaIntent);
productBuilder.addIntent(layoutIntent);
productBuilder.addIntent(bindingIntent);

// build product
Product prodcut = productBuilder.build();</programlisting></para>
      </section>

      <section>
        <title>ContactBuilder</title>

        <para>The Contact Node in XJDF keeps all customers contact details.
        There are several types of subnodes for holding the information. In
        order to simplify the creation and initialization of these elements
        the ContactBuilder class has been designed and developed.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ParameterSet Name="Contact"&gt;
        &lt;Parameter&gt;
            &lt;Contact ContactTypes="Customer Delivery"&gt;
                &lt;Address PostalCode="97080" City="Würzburg" 
                    Country="Germany" Street="Alfred-Nobel-Straße 18"/&gt;
                &lt;ComChannel ChannelType="Email" Locator="info@flyeralarm.de"/&gt;
                &lt;ComChannel ChannelType="Phone" Locator="+49.931.465840"/&gt;
                &lt;Company OrganizationName="flyeralarm GmbH"/&gt;
            &lt;/Contact&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    [...]
&lt;/XJDF&gt;</programlisting>Using the ContactBuilder Person-, Company-,
        Address- and ComChannel nodes easily can be created and added by plain
        method calls:</para>

        <para><programlisting language="java">// new ContactBuilder instance 
ContactBuilder contactBuilder = ContactBuilder.newInstance();

// set contact details
contactBuilder.addAddress("Alfred-Nobel-Straße 18", "97080", "Würzburg");
contactBuilder.addComChannel("Email", "info@flyeralarm.de");
contactBuilder.addComChannel("Phone", "+49.931.465840");
contactBuilder.addCompany("flyeralarm GmbH");

// build contact
Contact contact = contactBuilder.build();</programlisting></para>
      </section>
    </section>

    <section>
      <title>XJdfParser</title>

      <para>The XJdfParser writes an XJDF Document Object Tree to a binary
      stream and vice versa. Practical use cases are dealing with XJDF
      Documents and http transmissions or working on file system. Internally
      the parser class is working with the Java interfaces
      <emphasis>java.io.InputStream</emphasis> and
      <emphasis>java.io.OutputStream</emphasis>. So it doesn’t matter which
      kind of stream is used for reading or writing. Following a sample how to
      save a XJDF Document to local file system. For writing an XJDF Document
      to a http stream just use the specific implementation to achieve
      this.</para>

      <programlisting language="java">// any XJDF Document
XJDF xJdf = [...];

// target file
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
OutputStream os = new FileOutputStream(tmpFile);

// write XJDF Document to file using XJdfParser
XJdfParser xJdfParser = XJdfParser.newInstance();
xJdfParser.parseXJdf(xJdf, os);

// close stream
os.close();</programlisting>

      <para>When parsing XJDF Document Object Trees to a binary streams the
      document automatically is being validated against the XJDF Schema.
      Internally the <emphasis>XJdfValidator</emphasis> class is used to
      achieve this. In case the document is invalid a
      <emphasis>ValidationException</emphasis> is thrown. The message of the
      exception lists all points making the document invalid. In order to skip
      the validation process during parsing there is an optional parameter
      skipValidation in parseXJdf() method.</para>

      <programlisting language="java">// skip validation when parsing
xJdfParser.parseXJdf(xJdf, os, true);</programlisting>

      <para>In order to create an XJDF Object Tree from a binary stream the
      XJdfParser class contains a method <emphasis>parseStream()</emphasis>.
      This method accepts an InputStream as input parameter. Out of the box
      the Java framework provides many different implementations of this
      interface. All input streams easily can be parsed to an XJDF Document
      Object Tree by calling the method <emphasis>parseStream()</emphasis>.
      The sample below for example uses the
      <emphasis>FileInputStream</emphasis> implementation which is responsible
      for creating a <emphasis>InputStream</emphasis> from a local file. An
      InputStream created from a HttpRequest also would be suitable and often
      is being used when working with http transmissions.</para>

      <programlisting language="java">// open XJDF Document as InputStream
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
InputStream is = new FileInputStream(tmpFile);

// parse stream to XJDF Document Object Tree
XJdfParser xJdfParser = XJdfParser.newInstance();
XJDF xJdf = xJdfParser.parseStream(is);</programlisting>

      <note>
        <para>In order to analyze or extract details from a XJDF Document it
        is strongly recommended working with XPath expressions. Parsing the
        whole document and working with the DOM Tree Objects is no longer
        state of the art. This mechanism does consume time and raises code
        complexity. Besides parsing an InputStream also prones to errors
        because it requires fully conform documents. CIP4 xJdfLib provides an
        extra class <emphasis>XJdfNavigator</emphasis> for dealing with XPath
        expressions in XJDF Documents. XJDF is desinged for XPath so the
        preferred way reading XJDF Documents is XPath.</para>
      </note>
    </section>

    <section>
      <title>XJdfValidator</title>

      <para>The XJdfValidator class validates an XJDF Binary Stream against
      the latest XJDF Schema. A new instance is required per validation
      process. So when validating an XJDF Document first of all a new
      validator object has to be created using the static method
      <emphasis>newInstance()</emphasis>. The method
      <emphasis>isValid()</emphasis> runs the validation process and finally
      returns the result as Boolean.</para>

      <para>Out of the box all XJDF Documents created with the library
      automatically are being validated during parsing process. This mechanism
      explicitly can be switched off. For more details about that see
      XJdfParser.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// new instance of XJdfValidator
XJdfValidator xJdfValidator = XJdfValidator.newInstance(xJdfStream);

// get validation result
boolean result = xJdfValidator.isValid();</programlisting>

      <para> The validation procedure also can be done in a single
      line:</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// process validation in a single line
boolean result = XJdfValidator.newInstance(xJdfStream).isValid();</programlisting>

      <para>If a more detailed output is desired all errors are available as a
      list of Strings by calling the method
      <emphasis>getMessages()</emphasis>. In order to simplify user output (e.
      g. for the creation of exception messages) additionally there is an
      method <emphasis>getMessagesText()</emphasis> which converts all
      messages into a single String value.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// validate
XJdfValidator xJdfValidator = XJdfValidator.newInstance(xJdfStream);
boolean result = xJdfValidator.isValid();

// message output
List&lt;String&gt; messages = xJdfValidator.getMessages(); 
String msgText = xJdfValidator.getMessagesText(); </programlisting>
    </section>

    <section>
      <title>XJdfNavigator</title>

      <para>The XPathNavigator class covers functionality for reading and
      modifying XJDF Documents using XPath. XPath is a very common XML
      Technology for working with XML Documents. More details about the XPath
      W3C Standard can be found here: http://www.w3.org/TR/xpath/.</para>

      <para>XPathNavigator directly works with InputStream objects. So there
      is no need to parse the document first. This mechanism saves time, code
      complexity and performance. A XPathNavigator instance is required per
      XJDF Document processed. The method <emphasis>newInstance()
      </emphasis>creates a new object and initializes it by the XJDF Document
      InputStream. All XJDF Attributes can be addressed and read by using the
      method <emphasis>readAttribute()</emphasis> and the specific XPath
      expression as parameter. Modifications also can be done with XPath. The
      method updateAttribute() accepts parameters for a XPath definition and
      the (new) value of the attribute defined by the XPath. When
      modifications are completed the new XJDF Document stream is returned as
      InputStream by calling the method getXJdfStream().</para>

      <programlisting language="java">// load XJDF Document as InputStream and create new XPathNavigator.
InputStream is = […]
XPathNavigator xPathNavigator = XPathNavigator.newInstance(is);

// read JobID
String xJobId = "/XJDF/@JobID";
String jobId = xPathNavigator.readAttribute(xJobId);

// read GeneralID IDUsage
String xIdUsage = "/XJDF/GeneralID/@IDUsage";
String idUsage = xPathNavigator.readAttribute(xIdUsage);

// read FileSpec URL of partition "Cover"
String xFileCover = "/XJDF/ParameterSet[@Name='RunList']/"
                  +  "Parameter[./Part/@Run='Cover']/RunList/FileSpec/@URL";
String fileCover = xPathNavigator.readAttribute(xFileCover);

// update Product Amount to 1500
String xAmount = "/XJDF/ProductList/Product/@Amount";
xPathNavigator.updateAttribute(xAmount, "1500");

// get modified XJDF Document as InputStream
InputStream is = xPathNavigator.getXJdfStream();
[…]</programlisting>

      <para>All XPath definitions used in Java code snippet above references
      the XJDF Document sample below. This sample shows a pretty easy document
      of a web-to-print job submission.</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0" Category="Web2Print" 
    DescriptiveName="PrintJob 123456" JobID="FA-SIG-123456”&gt;
    &lt;GeneralID IDUsage="CatalogID" IDValue="46" /&gt;
    &lt;ProductList&gt;
        &lt;Product Amount="1000" /&gt;
    &lt;/ProductList&gt;
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Cover" /&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="cover.pdf" /&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Body" /&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="body.pdf" /&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
&lt;/XJDF&gt;</programlisting>
    </section>

    <section>
      <title>XJdfConstants</title>

      <para>Common XJDF constants are defined in the static class
      XJdfConstants. When working with XJDF Documents following values are
      commonly used:</para>

      <table>
        <title>Overview xJdfLib Constants</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Constant</entry>

              <entry align="center">Value</entry>

              <entry align="center">Use</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>NAMESPACE_JDF20</entry>

              <entry>"http://www.cip4.org/JDFSchema_2_0"</entry>

              <entry>JDF Default Namespace</entry>
            </row>

            <row>
              <entry>XJDF_CURRENT_VERSION</entry>

              <entry>"2.0"</entry>

              <entry>Current JDF Version Number</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JMF</entry>

              <entry>"application/vnd.cip4-jmf+xml"</entry>

              <entry>MIME Type JMF</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JDF</entry>

              <entry>"application/vnd.cip4-jdf+xml"</entry>

              <entry>MIME Type JDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>All constants are static and public. So they easily can be a
      accessed by typing the class name “XJdfConstants” and the specific name
      of a constant:</para>

      <programlisting language="java">// get XJDF default namespace
String defaultNamespace = XJdfConstants.NAMESPACE_JDF20;

// get current version of XJDF
String currentVersion = XJdfConstants.XJDF_CURRENT_VERSION;</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Developer Infos</title>

    <para>This chapter tells about the internals of the XJDF Library. This is
    useful when you are interest in getting involved to development. Otherwise
    fell free to skip it.</para>

    <section>
      <title>Update XJDF Schema</title>

      <para>Generating new sources after the XJDF Schema has changed is a very
      common task. The XSD is located at
      “src/main/resources/org/cip4/lib/xjdf/xsd/JDF20.xsd”. In order to update
      sources just overwrite the schema file and run the “updateXJdfXSD.bat”
      batch script. All files located in the java package
      “org.cip4.lib.xjdf.schema.jdf” automatically are being replaced.</para>
    </section>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>Currently the CIP4 xJdfLib project is still in a very early stadium.
    In addition the library is based on a Specification which has not been
    completely finished yet. So when using the library please keep in mind
    that concepts or even the XJDF structure may change from one version to
    the next. The first official stable version is indicated by starting with
    1 in version number (1.x).</para>

    <para>Feature requests and bug reports always are very welcome. Please do
    not hesitate to create a new ticket for your issues. In CIP4 JIRA Ticket
    System there you will find the project “xJdfLib” where you can place new
    posts.</para>
  </chapter>
</book>
