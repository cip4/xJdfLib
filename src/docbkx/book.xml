<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>CIP4 xJDFLib</title>

    <abstract>
      <para>This document describes the structure and functionality of CIP4
      xJdfLib and how to use it. The library is written in Java and manages
      the dealing with XJDF Documents and JMF Messages. It provides methods
      for creation, modification and analyzing.</para>
    </abstract>
  </info>

  <chapter>
    <title>Introduction</title>

    <para>The major conceptual change in JDF 2.0 (or XJDF) is that the
    technology no longer attempts to model the entire job as one large "job
    ticket" but rather specifies an interchange format between two
    applications that are assumed to have an internal data model that is not
    necessarily based on JDF. Thus each JDF ticket specifies a single
    transaction between two parties. A single job may be modeled as one or
    more JDF transactions.</para>

    <para>This fact also requires a conceptual change of the JDF libraries as
    well. Among other things the focus of 1.x libraries is dealing with large
    XML files (XML files were used as data storage), managing concurrency file
    access (spawn and merge) and handling the workflow logic (references).
    Also there are implemented very common XML functionalities like creating
    Java objects from XSD Schema etc.</para>

    <para>The fundamental concepts of JDF (and the library) were designed in
    the nineties. At this time XML was a very new technology and just a few
    early XML Tools had existed. Further, the XML technology itself was in a
    very early phase of development. Therefore, it was essential to include
    all the implementation specific details mentioned into the JDF
    Specification to get it working.</para>

    <para>Over the last two decades XML has become very popular. Many tools
    have been designed and many conceptual enhancements in XML have been done.
    For example, one significant enhancement is XPath. More details about the
    XPath W3C Standard later in this document or on the W3C website:
    http://www.w3.org/TR/xpath/.</para>

    <para>Due to the major change from JDF 1.x to JDF 2.0 a redesign of the
    JDF libraries is strongly recommended. The new CIP4 XJDF Library
    ("xJdfLib") is based on commonly used libraries and technologies like the
    Apache or JAXB framework. Supplementary functionality which has been
    removed from JDF Specification no longer makes the library unnecessarily
    complex for reasons of backwards compatibility. The goal of xJdfLib is to
    provide a lightweight, modern and easy to use library optimized for actual
    requirements. This document describes the concepts and the usage of the
    CIP4 xJdfLib.</para>
  </chapter>

  <chapter>
    <title>The xJdfLib Java Library</title>

    <para>The CIP4 xJdfLib Java Library is based on Java. The latest stable
    version always is being published on the CIP4 Website on page “Technical
    Resources -&gt; Downloads -&gt; Internal Source” or on the CIP4 Community
    Website (http://community.cip4.org). Furthermore, the library is an Apache
    Maven project. So the latest stable version also is available in the
    public Central Maven Repositroy:</para>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.5&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

    <para>Early Next-Version-Snapshots of the CIP4 xJdfLib Library are being
    published in the public OSS Sonatype Snapshot Repository or on the CIP4
    Community Website (http://community.cip4.org):</para>

    <programlisting language="xml">&lt;repository&gt;
    &lt;id&gt;SnapshotOSS&lt;/id&gt;
    &lt;name&gt;OSS Snapshot&lt;/name&gt;
    &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;</programlisting>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.6-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
  </chapter>

  <chapter>
    <title>Components Description</title>

    <section>
      <title>XJDF Data Types</title>

      <para>The XJDF Specification specifies several data types. At this time
      not all but the most significant data types already are implemented in
      CIP4 XJDF Java Library. The next versions of xJdfLib will complete the
      list step by step.</para>

      <para>All XJDF Type classes are derived from AbstractXJdfType and
      provide a custom <emphasis>toString()</emphasis> method for converting a
      data type to a string expression. The way around is coverted by a custom
      constructor. Each XJDF Data Type provides at least a default and several
      custom constructor for initializing.</para>

      <section>
        <title>DateTime</title>

        <para>A DateTime object represents a specific instant of time. It must
        be a Coordinated Universal Time (UTC) or the time zone must be
        indicated by the offset to UTC. In other words, the time must be
        unique in all time zones around the world.</para>

        <para>The XJDF DateTime object provides different constructors for
        initializing. The default constructor creates the current date as XJDF
        DateTime object whereas the custom constructors initialize the object
        by a custom value.</para>

        <programlisting language="java">// current time
DateTime d1 = new DateTime();
System.out.println(d1.toString()); // 2013-02-24T18:34:01+01:00

// specify date only
DateTime d2 = new DateTime(2013, 02, 24);
System.out.println(d2.toString()); // 2013-02-24T23:59:00+01:00

// specify date and time
DateTime d3 = new DateTime(2013, 02, 24, 15, 30);
System.out.println(d3.toString()); // 2013-02-24T15:30:00+01:00

// specify date as string
DateTime d4 = new DateTime("2013-02-24T18:30:00+00:00");
System.out.println(d4.toString()); // 2013-02-24T18:30:00Z

// initialize DateTime from Calendar
DateTime d5 = new DateTime(new GregorianCalendar());
System.out.println(d5.toString()); // 2013-02-24T18:42:46+01:00</programlisting>

        <para>Internally the XJDF DateTime object holds the information as
        Calendar. This object can also be accessed using the
        Getter-Method:</para>

        <programlisting language="java">// read DateTime
DateTime dateTime = new DateTime();
dateTime.getCalendar();</programlisting>
      </section>

      <section>
        <title>Duration</title>

        <para>Durations are a component of time intervals and define the
        amount of intervening time in a time interval. Durations are
        represented by the format P[n]Y[n]M[n]DT[n]H[n]M[n]S.</para>

        <para>The XJDF Duration object provides several constructors for
        initializing. The default constructor creates an empty XJDF Duration
        object whereas the custom constructors initialize the object by a
        custom value.</para>

        <programlisting language="java">// empty duration
Duration d1 = new Duration();
System.out.println(d1.toString()); // [no output]

// two days
Duration d2 = new Duration(2);
System.out.println(d2.toString()); // P2D

// two days and twelve hours
Duration d3 = new Duration(2, 12);
System.out.println(d3.toString()); // P2DT12H

// full initialization
Duration d4 = new Duration(1, 2, 3, 4, 5, 6);
System.out.println(d4.toString()); // P1Y2M3DT4H5M6S

// string expression
Duration d5 = new Duration("P3DT4H5M");
System.out.println(d5.toString()); // P3DT4H5M</programlisting>

        <para>All duration values can easily be accessed using the
        Getter-Methods:</para>

        <programlisting language="java">// read Duration
Duration duration = new Duration(0, 6);
int year = duration.getYear();
int month = duration.getMonth();
int day = duration.getDay();
int hour = duration.getHour(); // 6
int minute = duration.getMinute();
int second = duration.getSecond();</programlisting>
      </section>

      <section>
        <title>IDREF</title>

        <para>IDREF Represents the IDREF Attribute from XMLSchema. For a valid
        XML-document, an element with the ID value specified in IDREF must be
        present in the scope of the document.</para>

        <para>Currently the IDREF data type works only with Product and
        Parameter nodes. When constructing such a data type, the custom
        constructor requires either a node element or and node element with a
        custom id value. If no id value is provided, a new id value is
        generated automatically.</para>

        <programlisting>// IDREF with auto id generation
ProductBuilder productBuilder = new ProductBuilder(1500);
Product product = productBuilder.build();

IDREF idref = new IDREF(product);

System.out.println(idref.getId()); // PRD_XQZCG4ZK
System.out.println(product.getID()); // PRD_XQZCG4ZK</programlisting>

        <programlisting>// IDREF with custom ID
String customId = "PRD_1234";

ProductBuilder productBuilder = new ProductBuilder(1500);
Product product = productBuilder.build();

IDREF idref = new IDREF(product, customId);

System.out.println(idref.getId()); // PRD_1234
System.out.println(product.getID()); // PRD_1234</programlisting>
      </section>

      <section>
        <title>IntegerList</title>

        <para>An IntegerList is an enumerated set of Integers, which is
        expressed as a list of space separated values.</para>

        <para>The XJDF IntegerList object provides several constructors for
        initializing. The default constructor creates an empty XJDF
        IntegerList object whereas the custom constructors initialize the
        object by a custom value. That constructor which accepts a varible
        number of integer values is the most preferred one for creating
        IntegerList objects.</para>

        <programlisting language="java">// empty list
IntegerList l1 = new IntegerList();
System.out.println(l1.toString()); // [no output]

// integer list with 2 elements
IntegerList l2 = new IntegerList(4, 4);
System.out.println(l2.toString()); // 4 4

// integer list with 4 elements
IntegerList l3 = new IntegerList(1, 2, 3, 4);
System.out.println(l3.toString()); // 1 2 3 4

// string expresssion
IntegerList l4 = new IntegerList("2 2");
System.out.println(l4.toString()); // 2 2</programlisting>

        <para>Internally the XJDF IntegerList data type holds all items as a
        List of Integers. This list can be addressed using the
        Getter-Method:</para>

        <programlisting language="java">// read IntegerList
IntegerList integerList = new IntegerList(4, 0);
List&lt;Integer&gt; lst = integerList.getList();</programlisting>
      </section>

      <section>
        <title>Matrix</title>

        <para>Coordinate transformation matrices are widely used throughout
        the whole printing Process, especially in Layout Resources. They
        represent two dimensional transformations as defined by [PS] and
        [PDF1.6]. For more information, refer to the respective reference
        manuals, and look for "Coordinate Systems and Transformations." The
        "identity matrix", which is "1 0 0 1 0 0", is often used as a default
        throughout this specification. When another matrix is factored against
        a matrix with the identity matrix value, the result is that the
        original matrix remains unchanged. Coordinate transformation matrices
        are primitive data types and are encoded as a list of six numbers (as
        doubles), separated by whitespace: "a b c d Tx Ty". The variables Tx
        and Ty describe distances and are defined in points.</para>

        <para>The XJDF Matrix object provides several constructors for
        initializing. The default constructor creates a default XJDF Matrix
        object ("1 0 0 1 0 0") whereas the custom constructors initialize the
        object by a custom value.</para>

        <programlisting language="java">// default matrix
Matrix m1 = new Matrix();
System.out.println(m1.toString()); // 1.0 0.0 0.0 1.0 0.0 0.0

// custom matrix
Matrix m2 = new Matrix(1, 2, 3, 4, 5, 6);
System.out.println(m2.toString()); // 1.0 2.0 3.0 4.0 5.0 6.0

// string expression
Matrix m3 = new Matrix("2 2 4 4 0 0");
System.out.println(m3.toString()); // 2.0 2.0 4.0 4.0 0.0 0.0</programlisting>

        <para>In case a detailed access of all elements is required, the XJDF
        Matrix class provides several Getter-Methods to achieve this.</para>

        <programlisting>// read matrix
Matrix matrix = new Matrix(1, 2, 3, 4, 5, 6);
double a = matrix.getA(); // 1.0
double b = matrix.getB(); // 2.0
double c = matrix.getC(); // 3.0
double d = matrix.getD(); // 4.0
double tx = matrix.getTx(); // 5.0
double ty = matrix.getTy(); // 6.0</programlisting>
      </section>

      <section>
        <title>NMTokens</title>

        <para>NMTOKENS is an enumerated set of NMTOKEN, which is expressed as
        a list of space separated values.</para>

        <para>The XJDF NMTokens object provides several constructors for
        initializing. The default constructor creates an empty XJDF NMTokens
        object whereas the custom constructors initialize the object by custom
        values.</para>

        <programlisting language="java">// emtpy object
NMTokens n1 = new NMTokens();
System.out.println(n1.toString()); // [no output]

// multiple string expression
NMTokens n2 = new NMTokens("Val_1", "Val_2", "Val_3");
System.out.println(n2.toString()); // Val_1 Val_2 Val_3

// single string expression
NMTokens n3 = new NMTokens("Val_1 Val_2 Val_3");
System.out.println(n3.toString()); // Val_1 Val_2 Val_3</programlisting>

        <para>Internally the XJDF NMTokens data type holds all details as a
        List of Strings. This list can be addressed using the
        Getter-Method:</para>

        <programlisting language="java">// read NMTokens
NMTokens nmTokens = new NMTokens("Val_1 Val_2 Val_3");
List&lt;String&gt; lst = nmTokens.getList();</programlisting>
      </section>

      <section>
        <title>Rectangle</title>

        <para>Rectangles are used to describe rectangular locations on the
        page, sheet or other printable surface. A rectangle is represented as
        an array of four numbers — llx lly urx ury — specifying the lower-left
        x, lowerleft y, upper-right x and upper-right y coordinates of the
        rectangle, in that order. This is equivalent to the ordering: Left
        Bottom Right Top. All numbers are defined in points.</para>

        <para>The XJDF Rectangle object provides several constructors for
        initializing. The default constructor creates an empty XJDF Rectangle
        object whereas the custom constructors initialize the object by custom
        values.<programlisting>// empty rectangle
Rectangle r1 = new Rectangle();
System.out.println(r1.toString()); // 0.0 0.0 0.0 0.0

// customized rectangle
Rectangle r2 = new Rectangle(1, 2, 3, 4);
System.out.println(r2.toString()); // 1.0 2.0 3.0 4.0

Rectangle r3 = new Rectangle("2 4 6 8");
System.out.println(r3.toString()); // 2.0 4.0 6.0 8.0</programlisting></para>

        <para>All elements of the rectangle can be read using of the
        Getter-Methods:</para>

        <programlisting>// read Rectangle
Rectangle rectangle = new Rectangle(1, 2, 3, 4);
double llx = rectangle.getLlx();
double lly = rectangle.getLly();
double urx = rectangle.getUrx();
double ury = rectangle.getUry();</programlisting>
      </section>

      <section>
        <title>Shape</title>

        <para>Shape data types are used to describe a three dimensional box. A
        shape is represented as an array of three (positive or zero) numbers x
        y z specifying the Width x, height y and depth z coordinates of the
        shape, in that order.</para>

        <para>The XJDF Shape object provides several constructors for
        initializing. The default constructor creates an empty XJDF Shape
        object whereas the custom constructors initialize the object by custom
        values.</para>

        <programlisting>// empty shape
Shape s1 = new Shape();
System.out.println(s1.toString()); // 0.0 0.0 0.0

// definition of x and y only
Shape s2 = new Shape(4.5, 7.8);
System.out.println(s2.toString()); // 4.5 7.8 0.0

// definition of all elements
Shape s3 = new Shape(6.4, 5.7, 9.9);
System.out.println(s3.toString()); // 6.4 5.7 9.9

// string expression
Shape s4 = new Shape("3 5.6 8.0");
System.out.println(s4.toString()); // 3.0 5.6 8.0</programlisting>

        <para>All elements of the shape can be read using of the
        Getter-Methods:</para>

        <programlisting>// read Shape
Shape shape = new Shape(10.5, 15.2);
double x = shape.getX(); // 10.5
double y = shape.getY(); // 15.2
double z = shape.getZ(); // 0.0</programlisting>
      </section>

      <section>
        <title>XYPair</title>

        <para>XYPairs are used to describe sizes like Dimensions and
        StartPosition. They can also be used to describe positions on a page.
        All numbers that describe lengths are defined in points. XYPair
        Attributes are primitive data types and are encoded as a string of two
        numbers, separated by whitespace: "x y".</para>

        <para>The XJDF XYPair object provides several constructors for
        initializing. The default constructor creates an empty XJDF XYPair
        object whereas the custom constructors initialize the object by custom
        values.</para>

        <programlisting>// empty object
XYPair p1 = new XYPair();
System.out.println(p1.toString()); // 0.0 0.0

// definition of x and y
XYPair p2 = new XYPair(4.4, 5.9);
System.out.println(p2.toString()); // 4.4 5.9

// string expression
XYPair p3 = new XYPair("3 8.9");
System.out.println(p3.toString()); // 3.0 8.9</programlisting>

        <para>All elements of the XYPair can be read using of the
        Getter-Methods:</para>

        <programlisting>// read XYPair
XYPair xyPair = new XYPair(4.5, 5.0);
double x = xyPair.getX();
double y = xyPair.getY();</programlisting>
      </section>
    </section>

    <section>
      <title>XJdfParser</title>

      <para>The XJdfParser writes an XJDF Document Object Tree either to a
      binary stream or to a byte array and vice versa. Cases of practical use
      are dealing with XJDF Documents and http transmissions or working on
      file system. When using binary streams, internally the parser is working
      with the Java interfaces <emphasis>java.io.InputStream</emphasis> and
      <emphasis>java.io.OutputStream</emphasis>. So it doesn’t matter which
      kind of stream is used for reading or writing. The following is a sample
      of how to save an XJDF Document to a local file system.</para>

      <programlisting language="java">// any XJDF Document
XJDF xJdf = [...];

// target file
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
OutputStream os = new FileOutputStream(tmpFile);

// write XJDF Document to file using XJdfParser
XJdfParser xJdfParser = new XJdfParser();
xJdfParser.parseXJdf(xJdf, os);

// close stream
os.close();</programlisting>

      <para>The other option is working with a byte array. Here a sample of
      how to get a Byte Array from a XJDF Document:</para>

      <para><programlisting language="java">// any XJDF Document
XJDF xJdf = [...];

// write XJDF Document to file using XJdfParser
XJdfParser xJdfParser = new XJdfParser();
byte[] bytes = xJdfParser.parseXJdf(xJdf);</programlisting></para>

      <para>When parsing XJDF Document Object Trees to binary streams, the
      document is automatically being validated against the XJDF Schema.
      Internally the <emphasis>XJdfValidator</emphasis> class is used to
      achieve this. In case the document is invalid a
      <emphasis>ValidationException</emphasis> is thrown. The message of the
      exception lists all points making the document invalid. In order to skip
      the validation process during parsing there is an optional parameter
      skipValidation in parseXJdf() method.</para>

      <programlisting language="java">// skip validation when parsing
xJdfParser.parseXJdf(xJdf, os, true);</programlisting>

      <para>In order to create an XJDF Object Tree from a binary stream the
      XJdfParser class contains a method <emphasis>parseStream()</emphasis>.
      This method accepts an InputStream as input parameter. Out of the box
      the Java framework provides many different implementations of this
      interface. All InputStreams can easily be parsed to an XJDF Document
      Object Tree by calling the method <emphasis>parseStream()</emphasis>.
      The sample below, for example, uses the
      <emphasis>FileInputStream</emphasis> implementation which is responsible
      for creating an <emphasis>InputStream</emphasis> from a local file. An
      InputStream created from an HttpRequest also would be suitable and often
      is being used when working with http transmissions.</para>

      <programlisting language="java">// open XJDF Document as InputStream
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
InputStream is = new FileInputStream(tmpFile);

// parse stream to XJDF Document Object Tree
XJdfParser xJdfParser = XJdfParser.newInstance();
XJDF xJdf = xJdfParser.parseStream(is);</programlisting>

      <para>As before, there also is a second method for using Byte
      Arrays:</para>

      <programlisting language="java">// XJDF Byte Array
byte[] bytes = [...];

// write XJDF Document to file using XJdfParser
XJdfParser xJdfParser = new XJdfParser();
XJDF xJdf = xJdfParser.parseBytes(bytes);</programlisting>

      <note>
        <para>In order to analyze or extract details from an XJDF Document it
        is recommended to work with XPath expressions. Parsing the whole
        document and working with the DOM Tree Objects is no longer state of
        the art. This mechanism consumes time and raises code complexity.
        Besides, parsing an InputStream is also prone to errors because it
        requires fully conform documents. CIP4 xJdfLib provides an extra class
        <emphasis>XJdfNavigator</emphasis> for dealing with XPath expressions
        in XJDF Documents. XJDF is desinged for XPath so the preferred way of
        reading XJDF Documents is XPath.</para>
      </note>
    </section>

    <section>
      <title>XJdfNavigator</title>

      <para>The XJdfNavigator class provides functionality for reading,
      modifying and analyzing existing XJDF Documents using XPath. XPath is a
      very powerful and high-performance XML Technology for working with XML
      Documents. More details about the XPath W3C Standard can be found here:
      http://www.w3.org/TR/xpath/.</para>

      <para>XJdfNavigator directly works on InputStream or Byte Arrays, so
      there is no need to parse the document before hand. This mechanism saves
      time, code complexity and especially performance. One XJdfNavigator
      instance is required for each XJDF Document processed. There are several
      methods for reading, modifying and analyzing the document.</para>

      <section>
        <title>XPath Expressions</title>

        <para>The following is a short XPath overview of expressions which are
        significant to XJDF Documents. The XJDF snippet after is used for
        extracting these attribute values:</para>

        <table>
          <title>XPath expressions</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">XPath Expression</entry>

                <entry align="center">Attribute Value</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>/XJDF/GeneralID/@IDUsage</entry>

                <entry>"CatalogID"</entry>
              </row>

              <row>
                <entry>/XJDF/ParameterSet[@Name='RunList']/Parameter[./Part/@Run='Cover']/RunList/FileSpec/@URL</entry>

                <entry>"cover.pdf"</entry>
              </row>

              <row>
                <entry>/XJDF/ProductList/Product/@Amount</entry>

                <entry>"1500"</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Generated by CIP4 xJdfLib 0.5 --&gt;
&lt;xjdf:XJDF xmlns:xjdf="http://www.CIP4.org/JDFSchema_2_0" ID="XJDF_2GYLJJJG" 
    JobID="FA-SIG-123456" Category="Web2Print" Version="2.0"&gt;
    &lt;xjdf:GeneralID IDUsage="CatalogID" IDValue="46" /&gt;
    &lt;xjdf:ProductList&gt;
        &lt;xjdf:Product Amount="1500"/&gt;
    &lt;/xjdf:ProductList&gt;
    &lt;xjdf:ParameterSet Name="RunList"&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:RunList&gt;
                &lt;xjdf:FileSpec URL="cover.pdf"/&gt;
            &lt;/xjdf:RunList&gt;
            &lt;xjdf:Part Run="cover"/&gt;
        &lt;/xjdf:Parameter&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:RunList&gt;
                &lt;xjdf:FileSpec URL="body.pdf"/&gt;
            &lt;/xjdf:RunList&gt;
            &lt;xjdf:Part Run="body"/&gt;
        &lt;/xjdf:Parameter&gt;
    &lt;/xjdf:ParameterSet&gt;
&lt;/xjdf:XJDF&gt;</programlisting>

        <para>Commonly used XPath Expression also are provided as Java
        Constants in XJdfNavigator as well. Here a list of such predefined
        XPath Expressions:</para>

        <para><table>
            <title>Java Constants of XPath Expressions</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Java Constant Name</entry>

                  <entry align="center">Expression</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>JOB_ID</entry>

                  <entry>/XJDF/@JobID</entry>
                </row>

                <row>
                  <entry>CATEGORY</entry>

                  <entry>/XJDF/@Category</entry>
                </row>

                <row>
                  <entry>GENERAL_CATALOG_ID</entry>

                  <entry>/XJDF/GeneralID[@IDUsage='CatalogID']/@IDValue</entry>
                </row>

                <row>
                  <entry>GENERAL_LINE_ID</entry>

                  <entry>/XJDF/GeneralID[@IDUsage='LineID']/@IDValue</entry>
                </row>

                <row>
                  <entry>FILE_SPEC_URL</entry>

                  <entry>/XJDF/ParameterSet[@Name='RunList']/Parameter/RunList/FileSpec/@URL</entry>
                </row>

                <row>
                  <entry>MIN_APPROVALS</entry>

                  <entry>/XJDF/ParameterSet[@Name='ApprovalParams']/Parameter/ApprovalParams/@MinApprovals</entry>
                </row>

                <row>
                  <entry>CUSTOMER_ID</entry>

                  <entry>/XJDF/ParameterSet[@Name='CustomerInfo']/Parameter/CustomerInfo/@CustomerID</entry>
                </row>

                <row>
                  <entry>AMOUNT</entry>

                  <entry>/XJDF/ProductList/Product/@Amount</entry>
                </row>

                <row>
                  <entry>MEDIA_QUALITY</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='MediaIntent']/MediaIntent/@MediaQuality</entry>
                </row>

                <row>
                  <entry>LAYOUT_FINISHED_DIMENSIONS</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='LayoutIntent']/LayoutIntent/@FinishedDimensions</entry>
                </row>

                <row>
                  <entry>LAYOUT_DIMENSIONS</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='LayoutIntent']/LayoutIntent/@Dimensions</entry>
                </row>

                <row>
                  <entry>PRODUCTION_PRINT_PROCESS</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='ProductionIntent']/ProductionIntent/@PrintProcess</entry>
                </row>

                <row>
                  <entry>FOLD_CATALOG</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='FoldingIntent']/FoldingIntent/@FoldCatalog</entry>
                </row>

                <row>
                  <entry>COLOR_NUM_COLORS</entry>

                  <entry>/XJDF/ProductList/Product/Intent[@Name='ColorIntent']/ColorIntent/@NumColors</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section>
        <title>Read and Update Attributes</title>

        <para>All attributes in document easily can be addressed and read
        using the method <emphasis>readAttribute()</emphasis> and the specific
        XPath expression as parameter. Modifications can also be done. The
        method <emphasis>updateAttribute()</emphasis> accepts a XPath
        expression plus the (new) attribute value. When all modifications are
        done finally the new XJDF Document is returned as InputStream by
        calling the <emphasis>getXJdfStream()</emphasis> method or as Byte
        Array by calling the <emphasis>getXJdfBytes()</emphasis>
        method.</para>

        <programlisting language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is);

// define xPath
String xPath = "/XJDF/ProductList/Product/Intent[@Name='LayoutIntent']";
       xPath += "/LayoutIntent/@FinishedDimensions";

// read finished dimensions
String att = nav.readAttribute(xPath);

// modify attribute
att = att.replace("0.0", "2.222");

// update finished dimensions
nav.updateAttribute(xPath, att);

// output
byte[] bytes = nav.getXJdfBytes();
System.out.println(new String(bytes));</programlisting>

        <para>The sample above is working with String objects. The
        XJdfNavigator also provides a second way for reading and modifying
        based on XJDF Data Types. The following a Java code snippet which has
        quitely exactly the same functionalty but is using XJDF Data Types and
        Java Constants for XPath expressions:</para>

        <programlisting language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is);

// define xPath
String xPath = XJdfNavigator.LAYOUT_FINISHED_DIMENSIONS;

// read finished dimensions
Shape attShape = (Shape) nav.readAttribute(xPath, Shape.class);

// modify attribute
attShape = new Shape(attShape.getX(), attShape.getY(), 2.222);

// update finished dimensions
nav.updateAttribute(xPath, attShape);

// output
byte[] bytes = nav.getXJdfBytes();
System.out.println(new String(bytes));</programlisting>
      </section>

      <section>
        <title>Extended XPath Functionality</title>

        <para>Besides the simple read and update methods described above, the
        XJdfNavigator additionally provides evaluation methods for extended
        XPath functionality. The evaluation methods differs by their return
        value:</para>

        <para><table>
            <title>Overview Evaluation Methods</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Method</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>evaluateBoolean()</emphasis></entry>

                  <entry>Returns a <emphasis>Boolean</emphasis> object. This
                  method must be used in case the XPath expressions return a
                  Boolean value.</entry>
                </row>

                <row>
                  <entry><emphasis>evaluateDouble() </emphasis></entry>

                  <entry>Returns a <emphasis>Double</emphasis> object. This
                  method must be used in case the XPath expressions return a
                  Double value.</entry>
                </row>

                <row>
                  <entry><emphasis>evaluateInt()</emphasis></entry>

                  <entry>Returns a <emphasis>Integer</emphasis> object. This
                  method must be used in case the XPath expressions return a
                  Integer value.</entry>
                </row>

                <row>
                  <entry><emphasis>evaluateString()</emphasis></entry>

                  <entry>Returns a <emphasis>String</emphasis> object. This
                  method must be used in case the XPath expressions return a
                  String value.</entry>
                </row>

                <row>
                  <entry><emphasis>evaluateNode()</emphasis></entry>

                  <entry>Returns an <emphasis>org.w3c.dom.Node</emphasis>
                  object. This method must be used in case the XPath
                  expression returns a single node.</entry>
                </row>

                <row>
                  <entry><emphasis>evaluateNodeList()</emphasis></entry>

                  <entry>Returns an <emphasis>org.w3c.dom.NodeList</emphasis>
                  object. This method must be used in case the XPath
                  expression returns multiple nodes.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>The next few samples demonstrate how to use the evaluation
        methods in detail:</para>

        <programlisting language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is);

// get number of Intent nodes
String xPath = "count(/XJDF/ProductList/Product/Intent)";
int cnt = nav.evaluateInt(xPath);

// print result
System.out.println("Count: " + cnt);</programlisting>

        <programlisting language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is);

// read names of all Intent nodes
String xPath = "/XJDF/ProductList/Product/Intent";
NodeList nodes = nav.evaluateNodeList(xPath);

for (int i = 0; i &lt; nodes.getLength(); i++) {
    Node node = nodes.item(i);
    String name = node.getAttributes().getNamedItem("Name").getTextContent();
    System.out.println(name);
}</programlisting>

        <programlisting language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is);

// update node
String xPath = "/XJDF/ProductList/Product/Intent[@Name='MediaIntent']/MediaIntent";
Node node = nav.evaluateNode(xPath);
node.getAttributes().getNamedItem("MediaQuality").setNodeValue("IPM_170");

// output
byte[] bytes = nav.getXJdfBytes();
System.out.println(new String(bytes));</programlisting>
      </section>

      <section>
        <title>Namespace Awareness</title>

        <para>In some circumstances namespace awareness is required when
        working with XJdf Documents. Usually, all XML queries are executed
        namespace unaware but especially if you want to combine several XML
        Documents there is a need to be namespace aware. </para>
      </section>
    </section>

    <section>
      <title>XJdfNodeFactory</title>

      <para>The XJdfNodeFactory is the factory class for creating new
      instances of XJDF-Node-Objects. The class provides at least one simple
      Creation-Method per XJDF Node defined in XJDF Specification. Moreover,
      the class also provides extended Creation-Methods for commonly used
      nodes (e. g. GeneralID, RunList etc.) which also initializes the object
      after creation.</para>

      <programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();</programlisting>

      <para>Following a demonstration about the difference between simple and
      extended Creation-Methods. For example, when working with GeneralIDs
      most of them consist only of the attributes "IDUsage" and "IDValue".
      Using the simple method, the creation of such a GeneralID Node would
      require three lines of code. The first line creates the new Node-Object
      whereas the next two lines initialize the object. Each attribute
      explicitly is set by a setter call:</para>

      <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// New GeneralID XJDF Node Object using the simple method
GeneralID generalId = nf.createGeneralID();
generalId.setIDUsage("IDCatalog");
generalId.setIDValue("42");</programlisting>How ever, the creation of XJDF
      Documents only with the usage of simple Creation-Methods probably will
      consumes time and would raise code complexity. Extended Creation-Methods
      provides a more straighter way. Using these methods commonly used XJDF
      Nodes are able to be created and initialized by a single line of
      code:</para>

      <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// New GeneralID XJDF Node Object using the extended method
GeneralID generalId = nf.createGeneralID("IDCatalog", "42");</programlisting></para>

      <para>Both methods creates one and the same GeneralID Node. Simple
      methods raise the flexibility of attribute management whereas the
      extended ones decrease complexity, maintenance and produce a more
      clearly source code.</para>

      <para>It is recommended to use the extended Creation-Methods whenever
      there is one available. If the extended method does not fit the needs,
      the preinitialized node object always can be modified in a further line
      of code. For instance, in some situations the<emphasis>
      /RunList/FileSpec</emphasis> Node may contain an addtional attribute
      <emphasis>UserFileName</emphasis> which is not supported by an extended
      method:</para>

      <para><programlisting language="xml">[...]
&lt;xjdf:RunList&gt;
    &lt;xjdf:FileSpec URL="http://192.168.1.113:80/10496" 
        UserFileName="myFileName.pdf"/&gt;
&lt;/xjdf:RunList&gt;
[...]</programlisting>Here a demonstration how to realize such a modification
      in a further step:<programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// best practice creating indivudal nodes
RunList runList = nf.createRunList("http://192.168.1.113:80/10496");
runList.getFileSpec().setUserFileName("myFileName.pdf");</programlisting></para>
    </section>

    <section>
      <title>Builder Classes</title>

      <para>Most of the XJDF-Node-Objects can easily be created using the
      XJdfNodeFactory as described in the chapter before. How ever, more
      complex nodes like the XJDF-Root-Node or the Product-Node are nodes
      which contain a set of subnodes in a well defined structure. This
      requires additional logic to organize all child nodes within the parent
      node. Builder classes are designed to achieve this.</para>

      <para>For instance, the XJDF-Root-Node is the parent node for all
      Product- and Parameter-Nodes. All <emphasis>Product</emphasis> items are
      listed under the subelement <emphasis>ProductList</emphasis> whereas all
      <emphasis>Parameter</emphasis> nodes are listed within specific
      <emphasis>ParameterSet</emphasis> elements. So, when adding a new
      Parameter-Node, the builder class automatically checks whether the right
      <emphasis>ParameterSet</emphasis> element already does exist, or not. If
      not, the library creates a new element and finally puts the new
      parameter into the right position.</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Generated by CIP4 xJdfLib 0.4 --&gt;
&lt;xjdf:XJDF xmlns:xjdf="http://www.CIP4.org/JDFSchema_2_0" ID="XJDF_CCC45NIM" 
    DescriptiveName="My lovely Poster" JobID="FA-SIG-123456" 
    Category="Web2Print" Version="2.0"&gt;
    &lt;xjdf:ProductList&gt;
        &lt;xjdf:Product DescriptiveName="FA-PRD-123456" Amount="1500" 
            ProductType="Poster" ProductTypeDetails="PTD Value"&gt;
            &lt;xjdf:Intent Name="MediaIntent"&gt;
                &lt;xjdf:MediaIntent MediaQuality="IPM_90"/&gt;
            &lt;/xjdf:Intent&gt;
        &lt;/xjdf:Product&gt;
    &lt;/xjdf:ProductList&gt;
    &lt;xjdf:ParameterSet Name="RunList"&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:RunList&gt;
                &lt;xjdf:FileSpec URL="test_file.pdf"/&gt;
            &lt;/xjdf:RunList&gt;
        &lt;/xjdf:Parameter&gt;
    &lt;/xjdf:ParameterSet&gt;
    &lt;xjdf:ParameterSet Name="Contact"&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:Contact&gt;
                &lt;xjdf:Person FamilyName="Meissner" FirstName="Stefan"/&gt;
                &lt;xjdf:Company OrganizationName="flyeralarm GmbH"/&gt;
                &lt;xjdf:ComChannel ChannelType="Phone" 
                    Locator="tel:+49.931.465840"/&gt;
                &lt;xjdf:Address PostalCode="97082" City="Wuerzburg" 
                    Street="Alfred-Nobel-Strasse 15"/&gt;
            &lt;/xjdf:Contact&gt;
        &lt;/xjdf:Parameter&gt;
    &lt;/xjdf:ParameterSet&gt;
&lt;/xjdf:XJDF&gt;</programlisting></para>

      <para>The following the associated Java code snippet which shows how to
      create an XJDF Document as shown above:</para>

      <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// create XJDF Document
ProductBuilder productBuilder = new ProductBuilder(1500, "Poster", 
    "PTD Value", "FA-PRD-123456");
productBuilder.addIntent(nf.createMediaIntent("IPM_90"));
Product product = productBuilder.build();

ContactBuilder contactBuilder = new ContactBuilder();
contactBuilder.addCompany("flyeralarm GmbH");
contactBuilder.addPerson("Meissner", "Stefan", null);
contactBuilder.addAddress("Alfred-Nobel-Strasse 15", "97082", "Wuerzburg");
contactBuilder.addComChannel("Phone", "tel:+49.931.465840");
Contact contact = contactBuilder.build();

XJdfBuilder xJdfBuilder = new XJdfBuilder("FA-SIG-123456", "Web2Print", 
    "My lovely Poster");
xJdfBuilder.addParameter(nf.createRunList("test_file.pdf"));
xJdfBuilder.addParameter(contact);
xJdfBuilder.addProduct(product);
XJDF xjdf = xJdfBuilder.build();

// parse document
byte[] bytes = new XJdfParser().parseXJdf(xjdf);

// output
System.out.println(new String(bytes));</programlisting></para>

      <para>The current version of CIP4 XJdfLib provides the following builder
      classes:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><emphasis role="bold">XJdfBuilder</emphasis></para>

          <para>Creation of XJDF Documents. Manages the dealing with Products
          and Parameters.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ProductBuilder</emphasis></para>

          <para>Creation of Product-Nodes. Handles all Intent nodes.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ContactBuilder</emphasis></para>

          <para>Creation of Contact-Nodes. Organize the handling with contact
          details.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">LayoutBuilder</emphasis></para>

          <para>Creation of Layout-Nodes. Manages the handling with Layout
          elements.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>XJdfBuilder</title>

        <para>The XJdfBuilder is responsible for the creation and management
        of XJDF-Root-Nodes in a well defined structure. All child nodes are
        able to be appended by calling the associated "add-" method. The logic
        where exactly a specific node has to be put is covered by the builder
        class.</para>

        <para>For instance the XJDF Specification defines that all
        Parameter-Nodes have to be embedded within a specific ParameterSet
        element. This mechanism is fully supported by the builder class. So
        when adding a new Parameter item, the addParameter() method checks if
        the right ParameterSet-Node already exists. If not, a new one is
        created automatically. The following is a Java code snippet of how to
        use the XJdfBuilder.</para>

        <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

Contact contact = [...];
Product product = [...];

// create XJDF with builder
XJdfBuilder xJdfBuilder = XJdfBuilder.newInstance("FA-SIG-123456");
xJdfBuilder.addParameter(nf.createRunList("test_file.pdf"));
xJdfBuilder.addParameter(contact);
xJdfBuilder.addProduct(product);
XJDF xjdf = xJdfBuilder.build();

// build XJDF Doc
XJDF xJdf = xJdfBuilder.build();</programlisting></para>

        <section>
          <title>Partitioning of Parameter nodes</title>

          <para>Following a sample of a XJDF Document with a partitioned
          RunList. The XJDF Document references the PDF files for cover and
          body separately. This mechanism is called partitioning and requires
          an Part-Node per item.</para>

          <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Generated by CIP4 xJdfLib 0.4 --&gt;
&lt;xjdf:XJDF xmlns:xjdf="http://www.CIP4.org/JDFSchema_2_0" ID="XJDF_2GYLJJJG" 
    JobID="FA-SIG-123456" Category="Web2Print" Version="2.0"&gt;
    &lt;xjdf:ProductList&gt;
        &lt;xjdf:Product Amount="1500"/&gt;
    &lt;/xjdf:ProductList&gt;
    &lt;xjdf:ParameterSet Name="RunList"&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:RunList&gt;
                &lt;xjdf:FileSpec URL="cover.pdf"/&gt;
            &lt;/xjdf:RunList&gt;
            &lt;xjdf:Part Run="cover"/&gt;
        &lt;/xjdf:Parameter&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:RunList&gt;
                &lt;xjdf:FileSpec URL="body.pdf"/&gt;
            &lt;/xjdf:RunList&gt;
            &lt;xjdf:Part Run="body"/&gt;
        &lt;/xjdf:Parameter&gt;
    &lt;/xjdf:ParameterSet&gt;
&lt;/xjdf:XJDF&gt;</programlisting>Here a demonstration of how to create such
          partitioned XJDF Documents using the CIP4 XJDF Library. The
          XJdfBuilder class provides a further override of the addParameter()
          method to handle paritioning:</para>

          <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// create XJDF Document
ProductBuilder productBuilder = new ProductBuilder(1500);
Product product = productBuilder.build();

Part partCover = nf.createPart();
partCover.setRun("cover");

Part partBody = nf.createPart();
partBody.setRun("body");

XJdfBuilder xJdfBuilder = new XJdfBuilder("FA-SIG-123456", "Web2Print");
xJdfBuilder.addParameter(nf.createRunList("cover.pdf"), partCover);
xJdfBuilder.addParameter(nf.createRunList("body.pdf"), partBody);
xJdfBuilder.addProduct(product);
XJDF xjdf = xJdfBuilder.build();</programlisting></para>
        </section>
      </section>

      <section>
        <title>ProductBuilder</title>

        <para>The Product-Node is another signification element in an XJDF
        Document. This node specifies the product configuration how desired by
        the customer. In XJDF, most product configurations are defined as
        Intent-Nodes. A Product-Node consists of at least itself, its
        attributes and a set of Intent-Node subelements. The ProductBuilder
        organizes the creation of a Product-Node as well as the handling of
        all its Intent-Nodes.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Generated by CIP4 xJdfLib 0.4 --&gt;
&lt;xjdf:XJDF xmlns:xjdf="http://www.CIP4.org/JDFSchema_2_0" ID="XJDF_4Q1KC6OM" 
    JobID="FA-SIG-123456" Category="Web2Print" Version="2.0"&gt;
    &lt;xjdf:ProductList&gt;
        &lt;xjdf:Product Amount="1500"&gt;
            &lt;xjdf:Intent Name="MediaIntent"&gt;
                &lt;xjdf:MediaIntent MediaQuality="IPG_90"/&gt;
            &lt;/xjdf:Intent&gt;
            &lt;xjdf:Intent Name="LayoutIntent"&gt;
                &lt;xjdf:LayoutIntent Sides="TwoSidedHeadToHead" Pages="2" 
                    FinishedDimensions="297.63779528 419.52755906 0.0"/&gt;
            &lt;/xjdf:Intent&gt;
            &lt;xjdf:Intent Name="ColorIntent"&gt;
                &lt;xjdf:ColorIntent NumColors="4 4"/&gt;
            &lt;/xjdf:Intent&gt;
        &lt;/xjdf:Product&gt;
    &lt;/xjdf:ProductList&gt;
&lt;/xjdf:XJDF&gt;</programlisting>The following the associated Java code
        snippet for the creation of such a Product-Node:</para>

        <para><programlisting language="java">// new factory instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// create product node
ProductBuilder productBuilder = new ProductBuilder(1500);
productBuilder.addIntent(nf.createMediaIntent("IPG_90"));
productBuilder.addIntent(nf.createLayoutIntent(2, "TwoSidedHeadToHead", 
                                  new Shape(297.63779528, 419.52755906)));
productBuilder.addIntent(nf.createColorIntent(new IntegerList(4, 4)));
Product product = productBuilder.build();

XJdfBuilder xJdfBuilder = new XJdfBuilder("FA-SIG-123456", "Web2Print");
xJdfBuilder.addProduct(product);
XJDF xjdf = xJdfBuilder.build();</programlisting></para>

        <section>
          <title>Import Product-Node from existing XJDF Document</title>

          <para>Product elements can also be created by extracting existing
          Product-Nodes from XJDF Documents. In order to achieve this, the
          ProductBuilder provides a custom constructor which accepts and Node
          Object for initializing. Using the XJdfNavigator, a Product-Node can
          be extracted from an XJDF Document by evaluating an XPath
          Expression. Please keep in mind, Product-Nodes can only be imported
          if they were extracted Namespace-Aware. <programlisting
          language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is, true); // !! NAMESPACE AWARE !!

// get product node
Node node = navXJdf.evaluateNode("//xjdf:XJDF/xjdf:ProductList/xjdf:Product");

// create product from node
ProductBuilder productBuilder = new ProductBuilder(node);
Product product = productBuilder.build();</programlisting></para>
        </section>
      </section>

      <section>
        <title>ContactBuilder</title>

        <para>The ContactBuilder simplify the creation of Contact-Nodes.
        Contact-Nodes hold all the customers contact and delivery details and
        can be added as parameter to an XJDF Document. Usually, a contact
        parameter consists of the Contact-Node with at least an Address-Node,
        a Company-Node and a ComChannel-Node as subelements.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Generated by CIP4 xJdfLib 0.4 --&gt;
&lt;xjdf:XJDF xmlns:xjdf="http://www.CIP4.org/JDFSchema_2_0" ID="XJDF_C7C2Q04K" 
    JobID="FA-SIG-123456" Category="Web2Print" Version="2.0"&gt;
    &lt;xjdf:ParameterSet Name="Contact"&gt;
        &lt;xjdf:Parameter&gt;
            &lt;xjdf:Contact ContactTypes="Delivery Customer"&gt;
                &lt;xjdf:Person FamilyName="Meissner" FirstName="Stefan"/&gt;
                &lt;xjdf:Company OrganizationName="flyeralarm GmbH"/&gt;
                &lt;xjdf:ComChannel ChannelType="Phone" Locator="tel:+49.931.465840"/&gt;
                &lt;xjdf:Address PostalCode="97082" City="Wuerzburg" 
                                      Street="Alfred-Nobel-Strasse 15"/&gt;
            &lt;/xjdf:Contact&gt;
        &lt;/xjdf:Parameter&gt;
    &lt;/xjdf:ParameterSet&gt;
&lt;/xjdf:XJDF&gt;</programlisting>Using the ContactBuilder, all subnodes
        easily can be created and added by simple method calls:</para>

        <para><programlisting language="java">// create contact node
ContactBuilder contactBuilder = new ContactBuilder();
contactBuilder.addCompany("flyeralarm GmbH");
contactBuilder.addPerson("Meissner", "Stefan", null);
contactBuilder.addAddress("Alfred-Nobel-Strasse 15", "97082", "Wuerzburg");
contactBuilder.addComChannel("Phone", "tel:+49.931.465840");
contactBuilder.addContactType("Delivery");
contactBuilder.addContactType("Customer");
Contact contact = contactBuilder.build();

XJdfBuilder xJdfBuilder = new XJdfBuilder("FA-SIG-123456", "Web2Print");
xJdfBuilder.addParameter(contact);
XJDF xjdf = xJdfBuilder.build();</programlisting></para>

        <section>
          <title>Import Contact-Node from existing XJDF Document</title>

          <para>Contact elements can also be created by extracting existing
          Contact-Nodes from XJDF Documents. In order to achieve this, the
          ContactBuilder provides a custom constructor which accepts and Node
          Object for initializing. Using the XJdfNavigator, a Contact-Node can
          be extracted from an XJDF Document by evaluating an XPath
          Expression. Please keep in mind, Contact-Nodes can only be imported
          if they were extracted Namespace-Aware. <programlisting
          language="java">// load XJDF as InputStream
InputStream is = XJdfLibSamples.class.getResourceAsStream(RES_SIMPLE_PRODUCT);
XJdfNavigator nav = new XJdfNavigator(is, true); // !! NAMESPACE AWARE !!

// get product node
String xPath = "//xjdf:XJDF/xjdf:ParameterSet[@Name='Contact']/xjdf:Parameter/xjdf:Contact";
Node node = navXJdf.evaluateNode(xPath);

// create contact from node
ContactBuilder contactBuilder = new ContactBuilder(node);
Contact contact = contactBuilder.build();</programlisting></para>
        </section>
      </section>
    </section>

    <section>
      <title>XJdfValidator</title>

      <para>The XJdfValidator class validates an XJDF Binary Stream against
      the latest XJDF Schema. A new instance is required for each validation
      process. So when validating an XJDF Document, first of all a new
      validator object has to be created. The method
      <emphasis>isValid()</emphasis> runs the validation process and finally
      returns the result as Boolean.</para>

      <para>Out of the box all XJDF Documents created with the library are
      automatically being validated during the parsing process. This mechanism
      can be explicitly switched off. For more details about that see
      XJdfParser.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// new instance of XJdfValidator
XJdfValidator xJdfValidator = new XJdfValidator(xJdfStream);

// get validation result
boolean result = xJdfValidator.isValid();</programlisting>

      <para>The validation procedure also can be done in a single line:</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// process validation in a single line
boolean result = new XJdfValidator(xJdfStream).isValid();</programlisting>

      <para>If a more detailed output is desired all errors are available as a
      list of Strings by calling the <emphasis>getMessages()</emphasis>
      method. In order to simplify user output (e. g. for the creation of
      exception messages) there is an additional method
      <emphasis>getMessagesText(),</emphasis> which converts all messages into
      a single String value.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// validate
XJdfValidator xJdfValidator = XJdfValidator.newInstance(xJdfStream);
boolean result = xJdfValidator.isValid();

// message output
List&lt;String&gt; messages = xJdfValidator.getMessages(); 
String msgText = xJdfValidator.getMessagesText(); </programlisting>
    </section>

    <section>
      <title>XJdfPackager</title>

      <para>The XJdfPackager is responsible for the packaging of an XJDF
      Document including all its references into a ZIP Package. One instance
      is required for each XJDF Document processed. If necessary, the
      compression level can be adjusted manually using the method
      <emphasis>setCompressionLevel()</emphasis>. The optional parameter
      "docName" of method <emphasis>packageXJdf()</emphasis> defines the name
      of the XJDF Document file within the ZIP Package. Out of the box the
      documents name is the XJDFs JobID plus the extension ".xjdf". The
      following there is a demonstration how to use the XJdfPackager
      class:</para>

      <programlisting language="java">// path to artwork
String pathArtwork = XJdfLibSamples.class.getResource(RES_PDF_ARTWORK).getFile();

// build XJDF Document
XJdfNodeFactory nf = new XJdfNodeFactory();

ProductBuilder productBuilder = new ProductBuilder(1500);
Product product = productBuilder.build();

XJdfBuilder xJdfBuilder = new XJdfBuilder("JOB-12345678");
xJdfBuilder.addProduct(product);
xJdfBuilder.addParameter(nf.createRunList(pathArtwork));
XJDF xJdf = xJdfBuilder.build();

byte[] bytes = new XJdfParser().parseXJdf(xJdf, true);

// package to temporarily file
File tmp = File.createTempFile("XJdfPackage", "zip");
tmp.deleteOnExit();
OutputStream os = new FileOutputStream(tmp);

XJdfPackager packager = new XJdfPackager(bytes);
packager.setCompressionLevel(CompressionLevel.BEST_SPEED);
packager.packageXJdf(os);

os.close();</programlisting>

      <para>Beyond, when working with XJDF Documents as byte array, the
      XJDFPackager provides additional methods in order to achieve this. In
      case, the XJDF contains relative paths, a additional parameter rootPath
      is required for packaging.</para>
    </section>

    <section>
      <title>XJdfUnpackager</title>

      <para>The XJdfUnpackager class extracts an XJDF Package to the desired
      target directory. If no target destination is given (as below), the
      package is going to be extracted to a temporarily position. In both
      situations the method <emphasis>unpackageXJdf()</emphasis> returns the
      location of where the package has been unpacked.</para>

      <programlisting>// path to XJDF Package
String pathPackage = XJdfLibSamples.class.getResource(RES_XJDF_PACKAGE).getFile();

// new unpackager
XJdfUnpackager unpackager = new XJdfUnpackager();

// unpackage to temporarily target directory
String targetDir = unpackager.unpackageXJdf(pathPackage);</programlisting>
    </section>

    <section>
      <title>XJdfConstants</title>

      <para>When working with XJDF, there are several constants which are
      required in some cases. So the CIP4 xJdfLib also provides a static class
      <emphasis>XJdfConstants</emphasis>, where most common constants are
      already defined. Here is a list of all items in this class:</para>

      <table>
        <title>Overview xJdfLib Constants</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Constant</entry>

              <entry align="center">Value</entry>

              <entry align="center">Use</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>NAMESPACE_JDF20</entry>

              <entry>"http://www.cip4.org/JDFSchema_2_0"</entry>

              <entry>JDF Default Namespace</entry>
            </row>

            <row>
              <entry>NAMESPACE_W3_XML</entry>

              <entry>"http://www.w3.org/2001/XMLSchema"</entry>

              <entry>W3C XML Namespace</entry>
            </row>

            <row>
              <entry>XJDF_CURRENT_VERSION</entry>

              <entry>"2.0"</entry>

              <entry>Current JDF Version Number</entry>
            </row>

            <row>
              <entry>XJDF_LIB_VERSION</entry>

              <entry>"0.5"</entry>

              <entry>xJdfLib Version Number</entry>
            </row>

            <row>
              <entry>XJDF_LIB_BUILD_DATE</entry>

              <entry>"2013-08-24 21:53"</entry>

              <entry>xJdfLib Build Date</entry>
            </row>

            <row>
              <entry>JMF_ICS_VERSION</entry>

              <entry>"JMF_L1-2.0"</entry>

              <entry>JMF ICS Version Number</entry>
            </row>

            <row>
              <entry>XJDF_XSD_BYTES</entry>

              <entry><emphasis>[byte array]</emphasis></entry>

              <entry>XML Schema of XJDF as byte array</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JMF</entry>

              <entry>"application/vnd.cip4-jmf+xml"</entry>

              <entry>MIME Type JMF</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JDF</entry>

              <entry>"application/vnd.cip4-jdf+xml"</entry>

              <entry>MIME Type JDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>All constants are static and public. So they can be easily
      accessed by typing the class name XJdfConstants and the specific name of
      the constant:</para>

      <programlisting language="java">// get XJDF default namespace
String defaultNamespace = XJdfConstants.NAMESPACE_JDF20;

// get current version of XJDF
String currentVersion = XJdfConstants.XJDF_CURRENT_VERSION;</programlisting>
    </section>

    <section>
      <title>Util Classes</title>

      <para>Util classes provide tools and other simplifications for
      simplifying working with XJDF. The following is a list of all utils with
      a short description:</para>

      <table>
        <title>Overview Util classes</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Util Class</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>IDGeneratorUtil</entry>

              <entry>Generation of randomly created alphanumeric 8-digits IDs
              with or without customized prefix.</entry>
            </row>

            <row>
              <entry>DimensionUtil</entry>

              <entry>Conversion from millimeter to dtp and the way
              around.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Performance Optimizations</title>

      <para>The CIP4 XJDF Library is based on the Java JAX-B Framework. The
      framework brings a lot of benefits to the CIP4 xJdfLib but unfortunately
      the initialization takes a few seconds. Usually this happens
      automatically when the first XJDF Document is being parsed. In some
      cases this is not acceptable, thus the library provides additional
      functionalty for manual initialization. The XJdfFactory class is
      responsible for such a manual initialization processes. The
      <emphasis>init()</emphasis> method starts the process synchronously. By
      setting the parameter "initAsync", the same process starts
      asynchronously. The recommendation is using the asynchronous method when
      the application starts. By the way the manual initialization process
      also initializes some other components.</para>

      <programlisting language="java">// synchronous initialization
XJdfFactory.init();

// asynchronous initialization
XJdfFactory.init(true);</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Developer Infos</title>

    <para>This chapter describes the internals of the XJDF Library. This is
    useful when you are interested in getting involved in development.
    Otherwise feel free to skip it.</para>

    <section>
      <title>Update XJDF Schema</title>

      <para>Generating new sources after the XJDF Schema has changed is a very
      common task. The XSD is located at “src/main/resources/JDF21.xsd”. In order to update
      sources, just overwrite the schema file and run the “mvn generate-sources”
      script. All files located in the java package
      “org.cip4.lib.xjdf.schema.jdf” are automatically replaced.</para>
    </section>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>Currently the CIP4 xJdfLib project is still in a very early stadium.
    In addition the library is based on a specification which has not been
    completely finished yet. So when using the library please keep in mind
    that concepts or even the XJDF structure may change from one version to
    the next. The first official stable version is indicated by starting with
    1 in version number (1.x).</para>

    <para>Feature requests and bug reports are always very welcome. Please do
    not hesitate to create a new ticket for your issues. In CIP4 JIRA Ticket
    System there you will find the project “xJdfLib”, where you can place new
    posts.</para>
  </chapter>
</book>
