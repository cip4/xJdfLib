<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>CIP4 xJDFLib</title>

    <abstract>
      <para>This document describes the structure and functionality of CIP4
      xJdfLib and how to use it. The library is written in Java and manages
      the dealing with XJDF Documents and JMF Messages. It provides methods for
      creation, modification and analyzing.</para>
    </abstract>
  </info>

  <chapter>
    <title>Introduction</title>

    <para>The major conceptual change in JDF 2.0 (or XJDF) is that the
    technology no longer attempts to model the entire job as one large "job
    ticket" but rather specifies an interchange format between two
    applications that are assumed to have an internal data model that is not
    necessarily based on JDF. Thus each JDF ticket specifies a single
    transaction between two parties. A single job may be modeled as one or
    more JDF transactions.</para>

    <para>This fact also requires a conceptual change of the JDF libraries as
    well. Among other things the focus of 1.x libraries is dealing with large
    XML files (XML files were used as data storage), managing concurrency file
    access (spawn and merge) and handling the workflow logic (references).
    Also there are implemented very common XML functionalities like creating
    Java objects from XSD Schema etc.</para>

    <para>The fundamental concepts of JDF (and the library) were designed in
    the nineties. At this time XML was a very new technology and just a few
    early XML Tools had existed. Further, the XML technology itself was in a
    very early phase of development. Therefore, it was essential to include
    all the implementation specific details mentioned into the JDF
    Specification to get it working.</para>

    <para>Over the last two decades XML has become very popular. Many tools
    have been designed and many conceptual enhancements in XML have been done.
    For example, one significant enhancement is XPath. More details about the
    XPath W3C Standard later in this document or on the W3C website:
    http://www.w3.org/TR/xpath/.</para>

    <para>Due to the major change from JDF 1.x to JDF 2.0 a redesign of the
    JDF libraries is strongly recommended. The new CIP4 XJDF Library
    ("xJdfLib") is based on commonly used libraries and technologies like the
    Apache or JAXB framework. Supplementary functionality which has been
    removed from JDF Specification no longer makes the library unnecessarily
    complex for reasons of backwards compatibility. The goal of xJdfLib is to
    provide a lightweight, modern and easy to use library optimized for actual
    requirements. This document describes the concepts and the usage of the
    CIP4 xJdfLib.</para>
  </chapter>

  <chapter>
    <title>The xJdfLib Java Library</title>

    <para>The CIP4 xJdfLib Java Library is based on Java. The latest stable
    version always is being published on the CIP4 Website on page “Technical
    Resources -&gt; Downloads -&gt; Internal Source”. Furthermore, the library
    is an Apache Maven project. So the latest stable version also is available
    in the public Central Maven Repositroy:</para>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.4&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

    <para>Early Next-Version-Snapshots of the CIP4 xJdfLib Library are being
    published in the public OSS Sonatype Snapshot Repository:</para>

    <programlisting language="xml">&lt;repository&gt;
    &lt;id&gt;SnapshotOSS&lt;/id&gt;
    &lt;name&gt;OSS Snapshot&lt;/name&gt;
    &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;</programlisting>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.cip4.lib.xjdf&lt;/groupId&gt;
    &lt;artifactId&gt;xJdfLib&lt;/artifactId&gt;
    &lt;version&gt;0.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
  </chapter>

  <chapter>
    <title>Core Components</title>

    <section>
      <title>XJdfNodeFactory</title>

      <para>The XJdfNodeFactory is the factory class for creating new
      instances of XJDF-Node-Objects. The class provides at least one simple
      Creation-Method per XJDF Node defined in XJDF Specification. Moreover,
      the class also provides extended Creation-Methods for commonly used
      nodes (e. g. GeneralID, RunList etc.) which also initializes the object
      after creation. </para>

      <programlisting language="java">// New XJDF Factory Instance
XJdfNodeFactory nf = new XJdfNodeFactory();</programlisting>

      <para>Following a demonstration about the differance between simple and
      extended Creation-Methods. For example, when working with GeneralIDs
      most of them consist only of the attributes "IDUsage" and "IDValue".
      Using the simple method, the creation of such a GeneralID Node would
      require three lines of code. The first line creates the new Node-Object
      whereas the next two lines initialize the object. Each attribute
      explicitly is set by a setter call:</para>

      <para><programlisting language="java">// New XJDF Factory Instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// New GeneralID XJDF Node Object using the simple method
GeneralID generalId = nf.createGeneralID();
generalId.setIDUsage("IDCatalog");
generalId.setIDValue("42");</programlisting>How ever, the creation of XJDF
      Documents only with the usage of simple Creation-Methods probably will
      consumes time and would raise code complexity. Extended Creation-Methods
      provides a more straighter way. Using these methods commonly used XJDF
      Nodes are able to be created and initialized by a single line of
      code:</para>

      <para><programlisting language="java">// New XJDF Factory Instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// New GeneralID XJDF Node Object using the extended method
GeneralID generalId = nf.createGeneralID("IDCatalog", "42");</programlisting></para>

      <para>Both methods creates one and the same GeneralID Node. Simple
      methods raise the flexibility of attribute management whereas the
      extended ones decrease complexity, maintenance and produce a more
      clearly source code.</para>

      <para>It is recommended to use the extended Creation-Methods whenever
      there is one available. If the extended method does not fit the needs,
      the preinitialized node object always can be modified in a further line
      of code. For instance, in some situations the<emphasis>
      /RunList/FileSpec</emphasis> Node may contain an addtional attribute
      <emphasis>UserFileName</emphasis> which is not supported by an extended
      method:</para>

      <para><programlisting language="xml">[...]
&lt;xjdf:RunList&gt;
    &lt;xjdf:FileSpec URL="http://192.168.1.113:80/10496" 
        UserFileName="myFileName.pdf"/&gt;
&lt;/xjdf:RunList&gt;
[...]</programlisting>Here the demonstration how to realize such a
      modification in a further step:<programlisting language="java">// New XJDF Factory Instance
XJdfNodeFactory nf = new XJdfNodeFactory();

// Best practice creating indivudal nodes
RunList runList = nf.createRunList("http://192.168.1.113:80/10496");
runList.getFileSpec().setUserFileName("myFileName.pdf");</programlisting></para>
    </section>

    <section>
      <title>Builder Classes</title>

      <para>Plain XJDF Node elements can easily be created using the
      XJdfNodeFactory. Complex elements (e. g. XJDF-Root-Node, Product-Node,
      etc.) are elements which contain multiple subnodes in a defined manner.
      For example, you can say the XJDF-Root-Node is the container for Product
      and Parameter nodes. All <emphasis>Product</emphasis> items are listed
      in subelement <emphasis>ProductList</emphasis>. Also all
      <emphasis>Parameter</emphasis> nodes are listed in specific
      <emphasis>ParameterSet</emphasis> elements.</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0" Category="Web2Print" 
    DescriptiveName="My lovely Poster" JobID="FA-SIG-123456"&gt;
    &lt;ProductList&gt;
        &lt;Product DescriptiveName="1234_56" Amount="1500" ProductType="Poster"
            ProductID="FA-SIG-123456" ProductTypeDetails="PTD Value" &gt;
            &lt;Intent Name="MediaIntent"&gt;
                &lt;MediaIntent MediaQuality="IPM_90"/&gt;
            &lt;/Intent&gt;
        &lt;/Product&gt;
    &lt;/ProductList&gt;
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="test_file.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    &lt;ParameterSet Name="Contact"&gt;
        &lt;Parameter&gt;
            &lt;Contact ContactTypes="Customer Delivery"&gt;
                &lt;Address PostalCode="97080" City="Würzburg" 
                    Country="Germany" Street="Alfred-Nobel-Straße 18"/&gt;
                &lt;ComChannel ChannelType="Email" Locator="info@flyeralarm.de"/&gt;
                &lt;ComChannel ChannelType="Phone" Locator="+49.931.465840"/&gt;
                &lt;Company OrganizationName="flyeralarm GmbH"/&gt;
            &lt;/Contact&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
&lt;/XJDF&gt;</programlisting>Builder classes are designed and optimized to
      simplify creating the container element and dealing with all subnodes in
      a correct manner. In case of <date>XJdfBuilder</date> when adding a new
      <emphasis>Parameter</emphasis> node the class automatically checks
      whether the right <emphasis>ParameterSet</emphasis> element already
      exists. If not the library creates a new one and finally embeds the new
      parameter.</para>

      <para>The CIP4 XJdfLib provides several element builders:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><emphasis role="bold">XJdfBuilder</emphasis></para>

          <para>Creation of XJDF Documents. Manages dealing with Products and
          Parameters.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ProductBuilder</emphasis></para>

          <para>Creation of Product nodes. Handles Intent nodes.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">ContactBuilder</emphasis></para>

          <para>Creation of Contact nodes. Simplifies handling with contact
          details.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>XJdfBuilder</title>

        <para>The builder class XJdfBuilder covers logic to simplify the
        creation of XJDF Root Nodes and the handling of their Product and
        Parameter definitions. In order to add subelements there are several
        "add"-methods to achieve this. Additinally, these methods are
        responsible keeping the structure of the XJDF Document in a well
        defined manner. For instance the XJDF Specification defines all
        Parameter nodes have to be embedded within a specific ParameterSet
        element. This mechanism is fully supported by the builder class. So
        when adding a new Parameter item the addParameter() method checks
        whether or not the right ParameterSet node already exists. In case the
        ParameterSet node does not exist yet a new one is created
        automatically. The following is a Java Code Snippet of how to use the
        XJdfBuilder for creating the XJDF document above:</para>

        <para><programlisting language="java">// new xJdfBuilder
XJdfBuilder xJdfBuilder = XJdfBuilder.newInstance("FA-SIG-123456", 
                                             "Web2Print", "My lovely Poster");

// create Product node
ProductBuilder productBuilder = ProductBuilder.newInstance();
[...]
Product product = productBuilder.build();

// create Contact node
ContactBuilder contactBuilder = ContactBuilder.newInstance();
[...]
Contact contact = contactBuilder.build();

// create RunList
RunList runList = XJdfNodeFactory.newInstance().createRunList("test_file.pdf");

// append product
xJdfBuilder.addProduct(product);

// append parameters
xJdfBuilder.addParameter(contact);
xJdfBuilder.addParameter(runList);

// build XJDF Doc
XJDF xJdf = xJdfBuilder.build();</programlisting></para>

        <section>
          <title>Partitioning of Parameter nodes</title>

          <para>The XJDF Specification defines a partitioning mechanism of
          Parameters. Here an example of a partitioned RunList in an XJDF
          Document:</para>

          <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Cover"/&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="./artwork/cover.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Body"/&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="./artwork/body.pdf"/&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    [...]
&lt;/XJDF&gt;</programlisting>In XJdfBuilder class there is a particular
          addParameter() method override for partitioning. The following is
          the appendant code snippet for the creation of a partitioned RunList
          ParameterSet:</para>

          <para><programlisting language="java">// new factory
XJdfNodeFactory xJdfNodeFactory = XJdfNodeFactory.newInstance();

// new XJdfBuilder
XJdfBuilder xJdfBuilder = XJdfBuilder.newInstance();

// parameter cover
RunList runListCover = xJdfNodeFactory.createRunList("./artwork/cover.pdf");

Part partCover = XJdfNodeFactory.newInstance().createPart();
partCover.setRun("Cover");

// parameter body
RunList runListBody = xJdfNodeFactory.createRunList("./artwork/body.pdf");

Part partBody = XJdfNodeFactory.newInstance().createPart();
partBody.setRun("Body");

// add parameters with partitioning
xJdfBuilder.addParameter(runListCover, partCover);
xJdfBuilder.addParameter(runListBody, partBody);

// build XJDF
XJDF xJdf = xJdfBuilder.build();</programlisting></para>
        </section>
      </section>

      <section>
        <title>ProductBuilder</title>

        <para>The main task of ProductBuilder is the creation and
        initialization of new product instances. Further more, the classes
        proper is the handling of Product Intents. In XJDF each Product Intent
        has to be embedded within a separate Intent node. This mechanism also
        is covered by the ProductBuilder. When adding a new concrete Intent
        node (e. g. MediaIntent, LayoutIntent etc.) the class manages the
        structure.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ProductList&gt;
        &lt;Product ProductTypeDetails="MyJob" Amount="1500" ProductType="Poster"
            ProductID="FA-SIG-123456" &gt;
            &lt;Intent Name="MediaIntent"&gt;
                &lt;MediaIntent Weight="135.0" /&gt;
            &lt;/Intent&gt;
            &lt;Intent Name="LayoutIntent"&gt;
                &lt;LayoutIntent FinishedDimensions="595.27559055 822.04724409" /&gt;
            &lt;/Intent&gt;
            &lt;Intent Name="BindingIntent"&gt;
                &lt;BindingIntent BindingType="SaddleStitch" /&gt;
            &lt;/Intent&gt;
        &lt;/Product&gt;
    &lt;/ProductList&gt;
    [...]
&lt;/XJDF&gt;</programlisting>The snippet above shows a Product definition
        within an XJDF Document. Using the ProductBuilder class there is no
        longer a need to manage the document structure manually. The only
        thing to do is to create the particular Intent elements and add them
        to the builder:</para>

        <para><programlisting language="java">// new ProductBuilder instance 
ProductBuilder productBuilder = ProductBuilder.newInstance(1500, 
                                  "FA-SIG-123456", "Poster", "MyJob");

// create Intents
MediaIntent mediaIntent = [...];
LayoutIntent layoutIntent = [...];
BindingIntent bindingIntent = [...];

// add Intents
productBuilder.addIntent(mediaIntent);
productBuilder.addIntent(layoutIntent);
productBuilder.addIntent(bindingIntent);

// build product
Product prodcut = productBuilder.build();</programlisting></para>
      </section>

      <section>
        <title>ContactBuilder</title>

        <para>The Contact Node in XJDF keeps all customers contact details.
        There are several types of subnodes for holding the information. In
        order to simplify the creation and initialization of these elements
        the ContactBuilder class has been designed and developed.</para>

        <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0"&gt;
    [...]
    &lt;ParameterSet Name="Contact"&gt;
        &lt;Parameter&gt;
            &lt;Contact ContactTypes="Customer Delivery"&gt;
                &lt;Address PostalCode="97080" City="Würzburg" 
                    Country="Germany" Street="Alfred-Nobel-Straße 18"/&gt;
                &lt;ComChannel ChannelType="Email" Locator="info@flyeralarm.de"/&gt;
                &lt;ComChannel ChannelType="Phone" Locator="+49.931.465840"/&gt;
                &lt;Company OrganizationName="flyeralarm GmbH"/&gt;
            &lt;/Contact&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
    [...]
&lt;/XJDF&gt;</programlisting>Using the ContactBuilder Person-, Company-,
        Address- and ComChannel nodes easily can be created and added by plain
        method calls:</para>

        <para><programlisting language="java">// new ContactBuilder instance 
ContactBuilder contactBuilder = ContactBuilder.newInstance();

// set contact details
contactBuilder.addAddress("Alfred-Nobel-Straße 18", "97080", "Würzburg");
contactBuilder.addComChannel("Email", "info@flyeralarm.de");
contactBuilder.addComChannel("Phone", "+49.931.465840");
contactBuilder.addCompany("flyeralarm GmbH");

// build contact
Contact contact = contactBuilder.build();</programlisting></para>
      </section>
    </section>

    <section>
      <title>XJdfParser</title>

      <para>The XJdfParser writes an XJDF Document Object Tree to a binary
      stream and vice versa. Cases of practical use are dealing with XJDF
      Documents and http transmissions or working on file system. Internally,
      the parser class is working with the Java interfaces
      <emphasis>java.io.InputStream</emphasis> and
      <emphasis>java.io.OutputStream</emphasis>. So it doesn’t matter which
      kind of stream is used for reading or writing. The following is a sample
      of how to save an XJDF Document to a local file system. For writing an
      XJDF Document to a http stream just use the specific implementation to
      achieve this.</para>

      <programlisting language="java">// any XJDF Document
XJDF xJdf = [...];

// target file
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
OutputStream os = new FileOutputStream(tmpFile);

// write XJDF Document to file using XJdfParser
XJdfParser xJdfParser = XJdfParser.newInstance();
xJdfParser.parseXJdf(xJdf, os);

// close stream
os.close();</programlisting>

      <para>When parsing XJDF Document Object Trees to binary streams, the
      document is automatically being validated against the XJDF Schema.
      Internally the <emphasis>XJdfValidator</emphasis> class is used to
      achieve this. In case the document is invalid a
      <emphasis>ValidationException</emphasis> is thrown. The message of the
      exception lists all points making the document invalid. In order to skip
      the validation process during parsing there is an optional parameter
      skipValidation in parseXJdf() method.</para>

      <programlisting language="java">// skip validation when parsing
xJdfParser.parseXJdf(xJdf, os, true);</programlisting>

      <para>In order to create an XJDF Object Tree from a binary stream the
      XJdfParser class contains a method <emphasis>parseStream()</emphasis>.
      This method accepts an InputStream as input parameter. Out of the box
      the Java framework provides many different implementations of this
      interface. All InputStreams can easily be parsed to an XJDF Document
      Object Tree by calling the method <emphasis>parseStream()</emphasis>.
      The sample below, for example, uses the
      <emphasis>FileInputStream</emphasis> implementation which is responsible
      for creating an <emphasis>InputStream</emphasis> from a local file. An
      InputStream created from an HttpRequest also would be suitable and often
      is being used when working with http transmissions.</para>

      <programlisting language="java">// open XJDF Document as InputStream
File tmpFile = new File("/var/tmp/myXJdfDoc.xjdf");
InputStream is = new FileInputStream(tmpFile);

// parse stream to XJDF Document Object Tree
XJdfParser xJdfParser = XJdfParser.newInstance();
XJDF xJdf = xJdfParser.parseStream(is);</programlisting>

      <note>
        <para>In order to analyze or extract details from an XJDF Document it
        is strongly recommended to work with XPath expressions. Parsing the
        whole document and working with the DOM Tree Objects is no longer
        state of the art. This mechanism consumes time and raises code
        complexity. Besides, parsing an InputStream is also prone to errors
        because it requires fully conform documents. CIP4 xJdfLib provides an
        extra class <emphasis>XJdfNavigator</emphasis> for dealing with XPath
        expressions in XJDF Documents. XJDF is desinged for XPath so the
        preferred way of reading XJDF Documents is XPath.</para>
      </note>
    </section>

    <section>
      <title>XJdfValidator</title>

      <para>The XJdfValidator class validates an XJDF Binary Stream against
      the latest XJDF Schema. A new instance is required for each validation
      process. So when validating an XJDF Document, first of all a new
      validator object has to be created using the static method
      <emphasis>newInstance()</emphasis>. The method
      <emphasis>isValid()</emphasis> runs the validation process and finally
      returns the result as Boolean.</para>

      <para>Out of the box all XJDF Documents created with the library are
      automatically being validated during the parsing process. This mechanism
      can be explicitly switched off. For more details about that see
      XJdfParser.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// new instance of XJdfValidator
XJdfValidator xJdfValidator = XJdfValidator.newInstance(xJdfStream);

// get validation result
boolean result = xJdfValidator.isValid();</programlisting>

      <para>The validation procedure also can be done in a single line:</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// process validation in a single line
boolean result = XJdfValidator.newInstance(xJdfStream).isValid();</programlisting>

      <para>If a more detailed output is desired all errors are available as a
      list of Strings by calling the method
      <emphasis>getMessages()</emphasis>. In order to simplify user output (e.
      g. for the creation of exception messages) there is an additional method
      <emphasis>getMessagesText(),</emphasis> which converts all messages into
      a single String value.</para>

      <programlisting language="java">// get binary stream
InputStream xJdfStream = [...]

// validate
XJdfValidator xJdfValidator = XJdfValidator.newInstance(xJdfStream);
boolean result = xJdfValidator.isValid();

// message output
List&lt;String&gt; messages = xJdfValidator.getMessages(); 
String msgText = xJdfValidator.getMessagesText(); </programlisting>
    </section>

    <section>
      <title>XJdfNavigator</title>

      <para>The XPathNavigator class provides functionality for reading and
      modifying XJDF Documents using XPath. XPath is a very powerful XML
      Technology for working with XML Documents. More details about the XPath
      W3C Standard can be found here: http://www.w3.org/TR/xpath/.</para>

      <para>XPathNavigator directly works on InputStream objects, so there is
      no need to parse the document before hand. This mechanism saves time,
      code complexity and performance. One XPathNavigator instance is required
      for each XJDF Document processed. The method <emphasis>newInstance()
      </emphasis>creates a new object and initializes it by the XJDF Document
      InputStream. All attributes in document easily can be addressed and read
      using the method <emphasis>readAttribute()</emphasis> and the specific
      XPath expression as parameter. Modifications also can be done. The
      method <emphasis>updateAttribute()</emphasis> accepts a XPath expression
      plus the (new) attribute value. When all modifications are done finally
      the new XJDF Document stream is returned as InputStream by calling the
      method <emphasis>getXJdfStream():</emphasis></para>

      <programlisting language="java">// load XJDF Document as InputStream and create new XPathNavigator.
InputStream is = […]
XPathNavigator xPathNavigator = XPathNavigator.newInstance(is);

// read JobID
String xJobId = "/XJDF/@JobID";
String jobId = xPathNavigator.readAttribute(xJobId);

// read GeneralID IDUsage
String xIdUsage = "/XJDF/GeneralID/@IDUsage";
String idUsage = xPathNavigator.readAttribute(xIdUsage);

// read FileSpec URL of partition "Cover"
String xFileCover = "/XJDF/ParameterSet[@Name='RunList']/"
                  +  "Parameter[./Part/@Run='Cover']/RunList/FileSpec/@URL";
String fileCover = xPathNavigator.readAttribute(xFileCover);

// update Product Amount to 1500
String xAmount = "/XJDF/ProductList/Product/@Amount";
xPathNavigator.updateAttribute(xAmount, "1500");

// get modified XJDF Document as InputStream
InputStream is = xPathNavigator.getXJdfStream();
[…]</programlisting>

      <para>The following is a short XPath overview of expressions which are
      significant to XJDF Documents. The XJDF snippet after is used for
      extracting these attribute values:</para>

      <table>
        <title>XPath expressions</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">XPath Expression</entry>

              <entry align="center">Attribute Value</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>/XJDF/GeneralID/@IDUsage</entry>

              <entry>"CatalogID"</entry>
            </row>

            <row>
              <entry>/XJDF/ParameterSet[@Name='RunList']/Parameter[./Part/@Run='Cover']/RunList/FileSpec/@URL</entry>

              <entry>"cover.pdf"</entry>
            </row>

            <row>
              <entry>/XJDF/ProductList/Product/@Amount</entry>

              <entry>"1000"</entry>
            </row>

            <row>
              <entry/>
            </row>
          </tbody>
        </tgroup>
      </table>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;XJDF xmlns ="http://www.CIP4.org/JDFSchema_2_0" Category="Web2Print" 
    DescriptiveName="PrintJob 123456" JobID="FA-SIG-123456"&gt;
    &lt;GeneralID IDUsage="CatalogID" IDValue="46" /&gt;
    &lt;ProductList&gt;
        &lt;Product Amount="1000" /&gt;
    &lt;/ProductList&gt;
    &lt;ParameterSet Name="RunList"&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Cover" /&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="cover.pdf" /&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
        &lt;Parameter&gt;
            &lt;Part Run="Body" /&gt;
            &lt;RunList&gt;
                &lt;FileSpec URL="body.pdf" /&gt;
            &lt;/RunList&gt;
        &lt;/Parameter&gt;
    &lt;/ParameterSet&gt;
&lt;/XJDF&gt;</programlisting>
    </section>

    <section>
      <title>XJdfConstants</title>

      <para>When working with XJDF, there are several constants which are
      required in some use cases. So the CIP4 xJdfLib also provides a static
      class <emphasis>XJdfConstants</emphasis>, where most common constants
      are already defined. Here is a list of all items in this class:</para>

      <table>
        <title>Overview xJdfLib Constants</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Constant</entry>

              <entry align="center">Value</entry>

              <entry align="center">Use</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>NAMESPACE_JDF20</entry>

              <entry>"http://www.cip4.org/JDFSchema_2_0"</entry>

              <entry>JDF Default Namespace</entry>
            </row>

            <row>
              <entry>NAMESPACE_W3_XML</entry>

              <entry>"http://www.w3.org/2001/XMLSchema"</entry>

              <entry>W3C XML Namespace</entry>
            </row>

            <row>
              <entry>XJDF_CURRENT_VERSION</entry>

              <entry>"2.0"</entry>

              <entry>Current JDF Version Number</entry>
            </row>

            <row>
              <entry>XJDF_LIB_VERSION</entry>

              <entry>"0.4"</entry>

              <entry>xJdfLib Version Number</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JMF</entry>

              <entry>"application/vnd.cip4-jmf+xml"</entry>

              <entry>MIME Type JMF</entry>
            </row>

            <row>
              <entry>MEDIA_TYPE_VND_JDF</entry>

              <entry>"application/vnd.cip4-jdf+xml"</entry>

              <entry>MIME Type JDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>All constants are static and public. So they can be easily
      accessed by typing the class name XJdfConstants and the specific name of
      the constant:</para>

      <programlisting language="java">// get XJDF default namespace
String defaultNamespace = XJdfConstants.NAMESPACE_JDF20;

// get current version of XJDF
String currentVersion = XJdfConstants.XJDF_CURRENT_VERSION;</programlisting>
    </section>

    <section>
      <title>Converter Classes</title>

      <para>In order to convert from Java datatypes to JDF or ISO datatypes
      and the way around the library provides several converter classes. The
      following is a list of all converters with a short description:</para>

      <table>
        <title>Overview Converter classes</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Converter Class</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>DateConverter</entry>

              <entry>Conversion between the Java Calendar object and the ISO
              Date String how specified in XJDF Specification.</entry>
            </row>

            <row>
              <entry>DimensionConverter</entry>

              <entry>Conversion from millimeter to dtp and the way
              around.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>

  <chapter>
    <title>Developer Infos</title>

    <para>This chapter describes the internals of the XJDF Library. This is
    useful when you are interested in getting involved in development.
    Otherwise feel free to skip it.</para>

    <section>
      <title>Update XJDF Schema</title>

      <para>Generating new sources after the XJDF Schema has changed is a very
      common task. The XSD is located at
      “src/main/resources/org/cip4/lib/xjdf/xsd/JDF20.xsd”. In order to update
      sources, just overwrite the schema file and run the “updateXJdfXSD.bat”
      batch script. All files located in the java package
      “org.cip4.lib.xjdf.schema.jdf” are automatically replaced.</para>
    </section>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>Currently the CIP4 xJdfLib project is still in a very early stadium.
    In addition the library is based on a specification which has not been
    completely finished yet. So when using the library please keep in mind
    that concepts or even the XJDF structure may change from one version to
    the next. The first official stable version is indicated by starting with
    1 in version number (1.x).</para>

    <para>Feature requests and bug reports are always very welcome. Please do
    not hesitate to create a new ticket for your issues. In CIP4 JIRA Ticket
    System there you will find the project “xJdfLib”, where you can place new
    posts.</para>
  </chapter>
</book>
